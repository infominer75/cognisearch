Automata-based programming - Wikipedia, the free encyclopedia MediaWiki 1.18wmf1 Edit this page /w/index.php?title=Automata-based_programming&action=edit Edit this page /w/index.php?title=Automata-based_programming&action=edit //en.wikipedia.org/apple-touch-icon.png /favicon.ico /w/opensearch_desc.php Wikipedia (en) //en.wikipedia.org/w/api.php?action=rsd //creativecommons.org/licenses/by-sa/3.0/ Wikipedia Atom feed /w/index.php?title=Special:RecentChanges&feed=atom //bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&lang=en&modules=ext.wikihiero%7Cmediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&only=styles&skin=vector&* //bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&lang=en&modules=site&only=styles&skin=vector&* Automata-based programming From Wikipedia, the free encyclopedia Jump to: #mw-head navigation, #p-search search For other uses, see /wiki/Automata-based_programming_(Shalyto%27s_approach) Automata-based programming (Shalyto's approach) Automata-based programming (Shalyto's approach). /wiki/Programming_paradigm Programming paradigm Programming paradigms /wiki/Agent-oriented_programming Agent-oriented programming Agent-oriented Automata-based /wiki/Component-based_software_engineering Component-based software engineering Component-based /wiki/Flow-based_programming Flow-based programming Flow-based /wiki/Pipeline_programming Pipeline programming Pipelined /wiki/Concatenative_programming_language Concatenative programming language Concatenative /wiki/Concurrent_computing Concurrent computing Concurrent computing /wiki/Relativistic_programming Relativistic programming Relativistic programming /wiki/Data-driven_programming Data-driven programming Data-driven /wiki/Declarative_programming Declarative programming Declarative (contrast: /wiki/Imperative_programming Imperative programming Imperative) /wiki/Constraint_programming Constraint programming Constraint /wiki/Dataflow_programming Dataflow programming Dataflow Cell-oriented ( /wiki/Spreadsheet Spreadsheet spreadsheets) /wiki/Reactive_programming Reactive programming Reactive /wiki/Logic_programming Logic programming Logic /wiki/Abductive_logic_programming Abductive logic programming Abductive logic /wiki/Answer_set_programming Answer set programming Answer set /wiki/Constraint_logic_programming Constraint logic programming Constraint logic /wiki/Functional_logic_programming Functional logic programming Functional logic /wiki/Inductive_logic_programming Inductive logic programming Inductive logic /wiki/Event-driven_programming Event-driven programming Event-driven /wiki/Service-oriented_architecture Service-oriented architecture Service-oriented /wiki/Time-driven_programming Time-driven programming Time-driven /wiki/Expression-oriented_programming_language Expression-oriented programming language Expression-oriented /wiki/Feature_Oriented_Programming Feature Oriented Programming Feature-oriented /wiki/Function-level_programming Function-level programming Function-level (contrast: /wiki/Value-level_programming Value-level programming Value-level) /wiki/Functional_programming Functional programming Functional /wiki/Generic_programming Generic programming Generic /wiki/Imperative_programming Imperative programming Imperative (contrast: /wiki/Declarative_programming Declarative programming Declarative) /wiki/Procedural_programming Procedural programming Procedural /wiki/Language-oriented_programming Language-oriented programming Language-oriented /wiki/Service-oriented_modeling#Discipline-specific_modeling Service-oriented modeling Discipline-specific /wiki/Domain-specific_language Domain-specific language Domain-specific /wiki/Grammar-oriented_programming Grammar-oriented programming Grammar-oriented /wiki/Dialecting Dialecting Dialecting /wiki/Intentional_programming Intentional programming Intentional /wiki/Metaprogramming Metaprogramming Metaprogramming /wiki/Automatic_programming Automatic programming Automatic /wiki/Reflection_(computer_programming) Reflection (computer programming) Reflective /wiki/Attribute-oriented_programming Attribute-oriented programming Attribute-oriented /wiki/Template_metaprogramming Template metaprogramming Template /wiki/Policy-based_design Policy-based design Policy-based /wiki/Non-structured_programming Non-structured programming Non-structured (contrast: /wiki/Structured_programming Structured programming Structured) /wiki/Array_programming Array programming Array /wiki/Nondeterministic_programming Nondeterministic programming Nondeterministic /wiki/Parallel_computing Parallel computing Parallel computing /wiki/Process-oriented_programming Process-oriented programming Process-oriented /wiki/Programming_in_the_large_and_programming_in_the_small Programming in the large and programming in the small Programming in the large / small /wiki/Semantic-oriented_programming Semantic-oriented programming Semantic /wiki/Structured_programming Structured programming Structured (contrast: /wiki/Non-structured_programming Non-structured programming Non-structured) /wiki/Modular_programming Modular programming Modular (contrast: Monolithic) /wiki/Object-oriented_programming Object-oriented programming Object-oriented By /wiki/Separation_of_concerns Separation of concerns separation of concerns: /wiki/Aspect-oriented_programming Aspect-oriented programming Aspect-oriented /wiki/Role-oriented_programming Role-oriented programming Role-oriented /wiki/Subject-oriented_programming Subject-oriented programming Subject-oriented /wiki/Class-based_programming Class-based programming Class-based /wiki/Prototype-based_programming Prototype-based programming Prototype-based /wiki/Recursion_(computer_science) Recursion (computer science) Recursive /wiki/Value-level_programming Value-level programming Value-level (contrast: /wiki/Function-level_programming Function-level programming Function-level) /wiki/Template:Programming_paradigms Template:Programming paradigms View this template v /wiki/Template_talk:Programming_paradigms Template talk:Programming paradigms Discuss this template d //en.wikipedia.org/w/index.php?title=Template:Programming_paradigms&action=edit Edit this template e Automata-based programming is a /wiki/Programming_paradigm Programming paradigm programming paradigm in which the program or its part is thought of as a model of a /wiki/Finite_state_machine Finite state machine finite state machine (FSM) or any other (often more complicated) formal automaton (see /wiki/Automata_theory Automata theory automata theory). Sometimes a potentially-infinite set of possible states is introduced, and such a set can have a complicated structure, not just an enumeration. FSM-based programming is generally the same, but, formally speaking, doesn't cover all possible variants as FSM stands for /wiki/Finite_state_machine Finite state machine finite state machine and automata-based programming doesn't necessarily employ FSMs in the strict sense. The following properties are key indicators for automata-based programming: The time period of the program's execution is clearly separated down to the steps of the automaton. Each of the steps is effectively an execution of a code section (same for all the steps), which has a single entry point. Such a section can be a function or other routine, or just a cycle body. The step section might be divided down to subsection to be executed depending on different states, although this is not necessary. Any communication between the steps is only possible via the explicitly noted set of variables named the state. Between any two steps, the program (or its part created using the automata-based technique) can not have implicit components of its state, such as local (stack) variables' values, return addresses, the current instruction pointer etc. That is, the state of the whole program, taken at any two moments of entering the step of the automaton, can only differ in the values of the variables being considered as the state of the automaton. The whole execution of the automata-based code is a (possibly explicit) cycle of the automaton's steps. Another reason to use the notion of automata-based programming is that the programmer's style of thinking about the program in this technique is very similar to the style of thinking used to solve math-related tasks using /wiki/Turing_machine Turing machine Turing machine, /wiki/Markov_algorithm Markov algorithm Markov algorithm etc. Contents #Example 1 Example #Traditional_.28imperative.29_program_in_C 1.1 Traditional (imperative) program in C #Automata-based_style_program 1.2 Automata-based style program #A_separate_function_for_the_automation_step 1.3 A separate function for the automation step #Explicit_state_transition_table 1.4 Explicit state transition table #Automation_and_Automata 1.5 Automation and Automata #Example_Program 1.5.1 Example Program #Automation_.26_Events 1.5.2 Automation & Events #Using_object-oriented_capabilities 1.6 Using object-oriented capabilities #Applications 2 Applications #History 3 History #Compared_against_imperative_and_procedural_programming 4 Compared against imperative and procedural programming #Object-oriented_programming_relationship 5 Object-oriented programming relationship #See_also 6 See also #References 7 References #See_also_2 8 See also #External_links 9 External links [ /w/index.php?title=Automata-based_programming&action=edit&section=1 Edit section: Example edit] Example Consider a program in /wiki/C_(programming_language) C (programming language) C that reads a text from standard input stream, line by line, and prints the first word of each line. It is clear we need first to read and skip the leading spaces, if any, then read characters of the first word and print them until the word ends, and then read and skip all the remaining characters until the end-of-line character is encountered. Upon reaching the end of line character (regardless of the stage), we restart the algorithm from the beginning, and upon encountering the end of file condition (regardless of the stage), we terminate the program. [ /w/index.php?title=Automata-based_programming&action=edit&section=2 Edit section: Traditional (imperative) program in C edit] Traditional (imperative) program in C The program which solves the example task in traditional ( /wiki/Imperative_programming Imperative programming imperative) style can look something like this: #include <stdio.h> int main(void) { int c; do { c = getchar(); while(c == ' ') c = getchar(); while(c != EOF && c != ' ' && c != '\n') { putchar(c); c = getchar(); } putchar('\n'); while(c != EOF && c != '\n') c = getchar(); } while(c != EOF); return 0; } [ /w/index.php?title=Automata-based_programming&action=edit&section=3 Edit section: Automata-based style program edit] Automata-based style program The same task can be solved by thinking in terms of finite state machines. Note that line parsing has three stages: skipping the leading spaces, printing the word and skipping the trailing characters. Let's call them states before, inside and after. The program may now look like this: #include <stdio.h> int main(void) { enum states { before, inside, after } state; int c; state = before; while((c = getchar()) != EOF) { switch(state) { case before: if(c == '\n') { putchar('\n'); } else if(c != ' ') { putchar(c); state = inside; } break; case inside: switch(c) { case ' ': state = after; break; case '\n': putchar('\n'); state = before; break; default: putchar(c); } break; case after: if(c == '\n') { putchar('\n'); state = before; } } } return 0; } Although the code now looks longer, it has at least one significant advantage: there's only one reading (that is, call to the getchar() function) instruction in the program. Besides that, there's only one loop instead of the four the previous versions had. In this program, the body of the while loop is the automaton step, and the loop itself is the cycle of the automaton's work. /wiki/File:Automata_that_prints_the_first_word_of_each_line.png Automaton's diagram Automaton's diagram The program implements (models) the work of a finite state machine shown on the picture. The N denotes the end of line character, the S denotes spaces, and the A stands for all the other characters. The automaton follows exactly one arrow on each step depending on the current state and the encountered character. Some state switches are accompanied with printing the character; such arrows are marked with asterisks. It is not absolutely necessary to divide the code down to separate handlers for each unique state. Furthermore, in some cases the very notion of the state can be composed of several variables' values, so that it could be impossible to handle each possible state explicitly. In the discussed program it is possible to reduce the code length by noticing that the actions taken in response to the end of line character are the same for all the possible states. The following program is equal to the previous one but is a bit shorter: #include <stdio.h> int main(void) { enum states { before, inside, after } state; int c; state = before; while((c = getchar()) != EOF) { if(c == '\n') { putchar('\n'); state = before; } else switch(state) { case before: if(c != ' ') { putchar(c); state = inside; } break; case inside: if(c == ' ') { state = after; } else { putchar(c); } break; case after: break; } } return 0; } [ /w/index.php?title=Automata-based_programming&action=edit&section=4 Edit section: A separate function for the automation step edit] A separate function for the automation step The most important property of the previous program is that the automaton step code section is clearly localized. It is possible to demonstrate this property even better if we provide a separate function for it: #include <stdio.h> enum states { before, inside, after }; void step(enum states *state, int c) { if(c == '\n') { putchar('\n'); *state = before; } else switch(*state) { case before: if(c != ' ') { putchar(c); *state = inside; } break; case inside: if(c == ' ') { *state = after; } else { putchar(c); } break; case after: break; } } int main(void) { int c; enum states state = before; while((c = getchar()) != EOF) { step(&state, c); } return 0; } This example clearly demonstrates the basic properties of automata-based code: time periods of automaton step executions may not overlap the only information passed from the previous step to the next is the explicitly specified automaton state [ /w/index.php?title=Automata-based_programming&action=edit&section=5 Edit section: Explicit state transition table edit] Explicit state transition table A finite automaton can be defined by an explicit /wiki/State_transition_table State transition table state transition table. Generally speaking, an automata-based program code can naturally reflect this approach. In the program below there's an array named the_table, which defines the table. The rows of the table stand for three states, while columns reflect the input characters (first for spaces, second for the end of line character, and the last is for all the other characters). For every possible combination, the table contains the new state number and the flag, which determines whether the automaton must print the symbol. In a real life task, this could be more complicated; e.g., the table could contain pointers to functions to be called on every possible combination of conditions. #include <stdio.h> enum states { before = 0, inside = 1, after = 2 }; struct branch { unsigned char new_state:2; unsigned char should_putchar:1; }; struct branch the_table[3][3] = { /* ' ' '\n' others */ /* before */ { {before,0}, {before,1}, {inside,1} }, /* inside */ { {after, 0}, {before,1}, {inside,1} }, /* after */ { {after, 0}, {before,1}, {after, 0} } }; void step(enum states *state, int c) { int idx2 = (c == ' ') ? 0 : (c == '\n') ? 1 : 2; struct branch *b = & the_table[*state][idx2]; *state = (enum states)(b->new_state); if(b->should_putchar) putchar(c); } int main(void) { int c; enum states state = before; while((c = getchar()) != EOF) step(&state, c); return 0; } [ /w/index.php?title=Automata-based_programming&action=edit&section=6 Edit section: Automation and Automata edit] Automation and Automata Automata-based programming indeed closely matches the programming needs found in the field of /wiki/Automation Automation automation. A production cycle is commonly modelled as: A sequence of stages stepping according to input data (from captors). A set of actions performed depending on the current stage. Various dedicated programming languages allow expressing such a model in more or less sophisticated ways. [ /w/index.php?title=Automata-based_programming&action=edit&section=7 Edit section: Example Program edit] Example Program The example presented above could be expressed according to this view like in the following program. Here /wiki/Pseudo-code Pseudo-code pseudo-code uses such conventions: 'set' and 'reset' respectively activate & inactivate a logic variable (here a stage) ':' is assignment, '=' is equality test SPC : ' ' EOL : '\n' states : (before, inside, after, end) setState(c) { if c=EOF then set end if before and (c!=SPC and c!=EOL) then set inside if inside and (c=SPC or c=EOL) then set after if after and c=EOL then set before } doAction(c) { if inside then write(c) else if c=EOL then write(c) } cycle { set before loop { c : readCharacter setState(c) doAction(c) } until end } The separation of routines expressing cycle progression on one side, and actual action on the other (matching input & output) allows clearer and simpler code. [ /w/index.php?title=Automata-based_programming&action=edit&section=8 Edit section: Automation & Events edit] Automation & Events In the field of automation, stepping from step to step depends on input data coming from the machine itself. This is represented in the program by reading characters from a text. In reality, those data inform about position, speed, temperature, etc of critical elements of a machine. Like in /wiki/GUI GUI GUI programming, changes in the machine state can thus be considered as events causing the passage from a state to another, until the final one is reached. The combination of possible states can generate a wide variety of events, thus defining a more complex production cycle. As a consequence, cycles are usually far to be simple linear sequences. There are commonly parallel branches running together and alternatives selected according to different events, schematically represented below: s:stage c:condition s1 | |-c2 | s2 | ---------- | | |-c31 |-c32 | | s31 s32 | | |-c41 |-c42 | | ---------- | s4 [ /w/index.php?title=Automata-based_programming&action=edit&section=9 Edit section: Using object-oriented capabilities edit] Using object-oriented capabilities If the implementation language supports /wiki/Object-oriented_programming Object-oriented programming object-oriented programming, it is reasonable to /wiki/Encapsulation_(computer_science) Encapsulation (computer science) encapsulate the automaton into an object, thus hiding implementation details from the outer program. This approach is encompassed by a design pattern called /wiki/State_pattern State pattern state pattern. For example, the object-oriented version of the program mentioned before can look like this, implemented in /wiki/C%2B%2B C++ C++: #include <stdio.h> class StateMachine { enum states { before = 0, inside = 1, after = 2 } state; struct branch { enum states new_state:2; int should_putchar:1; }; static struct branch the_table[3][3]; public: StateMachine() : state(before) {} void FeedChar(int c) { int idx2 = (c == ' ') ? 0 : (c == '\n') ? 1 : 2; struct branch *b = & the_table[state][idx2]; state = b->new_state; if(b->should_putchar) putchar(c); } }; struct StateMachine::branch StateMachine::the_table[3][3] = { /* ' ' '\n' others */ /* before */ { {before,0}, {before,1}, {inside,1} }, /* inside */ { {after, 0}, {before,1}, {inside,1} }, /* after */ { {after, 0}, {before,1}, {after, 0} } }; int main(void) { int c; StateMachine machine; while((c = getchar()) != EOF) machine.FeedChar(c); return 0; } Note: To minimize changes not directly related to the subject of the article, the input/output functions from the standard library of /wiki/C_(programming_language) C (programming language) C are being used. Note the use of the /wiki/Ternary_operator Ternary operator ternary operator, which could also be implemented as if-else. [ /w/index.php?title=Automata-based_programming&action=edit&section=10 Edit section: Applications edit] Applications Automata-based programming is widely used in /wiki/Lexical_analysis Lexical analysis lexical and /wiki/Syntactic_analysis Syntactic analysis syntactic analyses. #cite_note-gram-0 [1] Besides that, thinking in terms of automata (that is, breaking the execution process down to automaton steps and passing information from step to step through the explicit state) is necessary for /wiki/Event-driven_programming Event-driven programming event-driven programming as the only alternative to using parallel processes or threads. The notions of states and state machines are often used in the field of /wiki/Formal_specification Formal specification formal specification. For instance, /wiki/Unified_Modeling_Language Unified Modeling Language UML-based software architecture development uses /wiki/State_diagram#UML_state_diagram State diagram state diagrams to specify the behaviour of the program. Also various /wiki/Communication_protocol Communication protocol communication protocols are often specified using the explicit notion of state (see, e.g., //tools.ietf.org/html/rfc793 RFC 793 #cite_note-1 [2]). Thinking in terms of automata (steps and states) can also be used to describe semantics of some /wiki/Programming_language Programming language programming languages. For example, the execution of a program written in the /wiki/Refal Refal Refal language is described as a sequence of steps of a so-called abstract Refal machine; the state of the machine is a view (an arbitrary Refal expression without variables). /wiki/Continuations Continuations Continuations in the /wiki/Scheme_(programming_language) Scheme (programming language) Scheme language require thinking in terms of steps and states, although Scheme itself is in no way automata-related (it is recursive). To make it possible the /wiki/Call/cc Call/cc call/cc feature to work, implementation needs to be able to catch a whole state of the executing program, which is only possible when there's no implicit part in the state. Such a caught state is the very thing called continuation, and it can be considered as the state of a (relatively complicated) automaton. The step of the automaton is deducing the next continuation from the previous one, and the execution process is the cycle of such steps. Alexander Ollongren in his book #cite_note-2 [3] explains the so-called Vienna method of programming languages semantics description which is fully based on formal automata. The STAT system http://www.cs.ucsb.edu/~seclab/projects/stat/index.html [1] is a good example of using the automata-based approach; this system, besides other features, includes an embedded language called STATL which is purely automata-oriented. [ /w/index.php?title=Automata-based_programming&action=edit&section=11 Edit section: History edit] History Automata-based techniques were used widely in the domains where there are algorithms based on automata theory, such as formal language analyses. #cite_note-gram-0 [1] One of the early papers on this is by Johnson et al., 1968. #cite_note-3 [4] One of the earliest mentions of automata-based programming as a general technique is found in the paper by /wiki/Peter_Naur Peter Naur Peter Naur, 1963. #cite_note-4 [5] The author calls the technique Turing machine approach, however no real /wiki/Turing_machine Turing machine Turing machine is given in the paper; instead, the technique based on states and steps is described. [ /w/index.php?title=Automata-based_programming&action=edit&section=12 Edit section: Compared against imperative and procedural programming edit] Compared against imperative and procedural programming The notion of /wiki/State_(computer_science) State (computer science) state is not exclusive property of automata-based programming. #cite_note-5 [6] Generally speaking, state (or /wiki/Program_state Program state program state) appears during execution of any /wiki/Computer_program Computer program computer program, as a combination of all information
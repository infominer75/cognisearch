Functional programming - Wikipedia, the free encyclopedia MediaWiki 1.18wmf1 Edit this page /w/index.php?title=Functional_programming&action=edit Edit this page /w/index.php?title=Functional_programming&action=edit //en.wikipedia.org/apple-touch-icon.png /favicon.ico /w/opensearch_desc.php Wikipedia (en) //en.wikipedia.org/w/api.php?action=rsd //creativecommons.org/licenses/by-sa/3.0/ Wikipedia Atom feed /w/index.php?title=Special:RecentChanges&feed=atom //bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&lang=en&modules=ext.wikihiero%7Cmediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&only=styles&skin=vector&* //bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&lang=en&modules=site&only=styles&skin=vector&* Functional programming From Wikipedia, the free encyclopedia Jump to: #mw-head navigation, #p-search search For subroutine-oriented programming, see /wiki/Procedural_programming Procedural programming Procedural programming. /wiki/Programming_paradigm Programming paradigm Programming paradigms /wiki/Agent-oriented_programming Agent-oriented programming Agent-oriented /wiki/Automata-based_programming Automata-based programming Automata-based /wiki/Component-based_software_engineering Component-based software engineering Component-based /wiki/Flow-based_programming Flow-based programming Flow-based /wiki/Pipeline_programming Pipeline programming Pipelined /wiki/Concatenative_programming_language Concatenative programming language Concatenative /wiki/Concurrent_computing Concurrent computing Concurrent computing /wiki/Relativistic_programming Relativistic programming Relativistic programming /wiki/Data-driven_programming Data-driven programming Data-driven /wiki/Declarative_programming Declarative programming Declarative (contrast: /wiki/Imperative_programming Imperative programming Imperative) /wiki/Constraint_programming Constraint programming Constraint /wiki/Dataflow_programming Dataflow programming Dataflow Cell-oriented ( /wiki/Spreadsheet Spreadsheet spreadsheets) /wiki/Reactive_programming Reactive programming Reactive /wiki/Logic_programming Logic programming Logic /wiki/Abductive_logic_programming Abductive logic programming Abductive logic /wiki/Answer_set_programming Answer set programming Answer set /wiki/Constraint_logic_programming Constraint logic programming Constraint logic /wiki/Functional_logic_programming Functional logic programming Functional logic /wiki/Inductive_logic_programming Inductive logic programming Inductive logic /wiki/Event-driven_programming Event-driven programming Event-driven /wiki/Service-oriented_architecture Service-oriented architecture Service-oriented /wiki/Time-driven_programming Time-driven programming Time-driven /wiki/Expression-oriented_programming_language Expression-oriented programming language Expression-oriented /wiki/Feature_Oriented_Programming Feature Oriented Programming Feature-oriented /wiki/Function-level_programming Function-level programming Function-level (contrast: /wiki/Value-level_programming Value-level programming Value-level) Functional /wiki/Generic_programming Generic programming Generic /wiki/Imperative_programming Imperative programming Imperative (contrast: /wiki/Declarative_programming Declarative programming Declarative) /wiki/Procedural_programming Procedural programming Procedural /wiki/Language-oriented_programming Language-oriented programming Language-oriented /wiki/Service-oriented_modeling#Discipline-specific_modeling Service-oriented modeling Discipline-specific /wiki/Domain-specific_language Domain-specific language Domain-specific /wiki/Grammar-oriented_programming Grammar-oriented programming Grammar-oriented /wiki/Dialecting Dialecting Dialecting /wiki/Intentional_programming Intentional programming Intentional /wiki/Metaprogramming Metaprogramming Metaprogramming /wiki/Automatic_programming Automatic programming Automatic /wiki/Reflection_(computer_programming) Reflection (computer programming) Reflective /wiki/Attribute-oriented_programming Attribute-oriented programming Attribute-oriented /wiki/Template_metaprogramming Template metaprogramming Template /wiki/Policy-based_design Policy-based design Policy-based /wiki/Non-structured_programming Non-structured programming Non-structured (contrast: /wiki/Structured_programming Structured programming Structured) /wiki/Array_programming Array programming Array /wiki/Nondeterministic_programming Nondeterministic programming Nondeterministic /wiki/Parallel_computing Parallel computing Parallel computing /wiki/Process-oriented_programming Process-oriented programming Process-oriented /wiki/Programming_in_the_large_and_programming_in_the_small Programming in the large and programming in the small Programming in the large / small /wiki/Semantic-oriented_programming Semantic-oriented programming Semantic /wiki/Structured_programming Structured programming Structured (contrast: /wiki/Non-structured_programming Non-structured programming Non-structured) /wiki/Modular_programming Modular programming Modular (contrast: Monolithic) /wiki/Object-oriented_programming Object-oriented programming Object-oriented By /wiki/Separation_of_concerns Separation of concerns separation of concerns: /wiki/Aspect-oriented_programming Aspect-oriented programming Aspect-oriented /wiki/Role-oriented_programming Role-oriented programming Role-oriented /wiki/Subject-oriented_programming Subject-oriented programming Subject-oriented /wiki/Class-based_programming Class-based programming Class-based /wiki/Prototype-based_programming Prototype-based programming Prototype-based /wiki/Recursion_(computer_science) Recursion (computer science) Recursive /wiki/Value-level_programming Value-level programming Value-level (contrast: /wiki/Function-level_programming Function-level programming Function-level) /wiki/Template:Programming_paradigms Template:Programming paradigms View this template v /wiki/Template_talk:Programming_paradigms Template talk:Programming paradigms Discuss this template d //en.wikipedia.org/w/index.php?title=Template:Programming_paradigms&action=edit Edit this template e In /wiki/Computer_science Computer science computer science, functional programming is a /wiki/Programming_paradigm Programming paradigm programming paradigm that treats /wiki/Computation Computation computation as the evaluation of /wiki/Function_(mathematics) Function (mathematics) mathematical functions and avoids /wiki/Program_state Program state state and /wiki/Immutable_object Immutable object mutable data. It emphasizes the application of functions, in contrast to the /wiki/Imperative_programming Imperative programming imperative programming style, which emphasizes changes in state. #cite_note-hudak1989-0 [1] Functional programming has its roots in /wiki/Lambda_calculus Lambda calculus lambda calculus, a /wiki/Formal_system Formal system formal system developed in the 1930s to investigate function definition, function application, and /wiki/Recursion Recursion recursion. Many functional /wiki/Programming_language Programming language programming languages can be viewed as elaborations on the lambda calculus. #cite_note-hudak1989-0 [1] In practice, the difference between a mathematical function and the notion of a "function" used in imperative programming is that imperative functions can have /wiki/Side_effect_(computer_science) Side effect (computer science) side effects, changing the value of program state. Because of this, they lack /wiki/Referential_transparency_(computer_science) Referential transparency (computer science) referential transparency, i.e. the same language expression can result in different values at different times depending on the state of the executing program. Conversely, in functional code, the output value of a function depends only on the arguments that are input to the function, so calling a function f twice with the same value for an argument x will produce the same result f(x) both times. Eliminating side effects can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming. #cite_note-hudak1989-0 [1] Functional programming languages, especially /wiki/Purely_functional Purely functional purely functional ones, have largely been emphasized in /wiki/Academic Academic academia rather than in commercial software development. However, prominent functional programming languages such as /wiki/Common_Lisp Common Lisp Common /wiki/Lisp_(programming_language) Lisp (programming language) Lisp, /wiki/Scheme_(programming_language) Scheme (programming language) Scheme, #cite_note-clinger1987-1 [2] #cite_note-hartheimer1987-2 [3] #cite_note-kidd2007-3 [4] #cite_note-cleis2006-4 [5] /wiki/Clojure Clojure Clojure, /wiki/Racket_(programming_language) Racket (programming language) Racket, #cite_note-racket-video-games-5 [6] /wiki/Erlang_(programming_language) Erlang (programming language) Erlang, #cite_note-erlang-faq-6 [7] #cite_note-armstrong2007-7 [8] #cite_note-larson2009-8 [9] /wiki/Objective_Caml Objective Caml Objective Caml, #cite_note-minksy2008-9 [10] #cite_note-leroy2007-10 [11] /wiki/Haskell_(programming_language) Haskell (programming language) Haskell #cite_note-haskell-industry-11 [12] #cite_note-hudak2007-12 [13] and /wiki/F_Sharp_(programming_language) F Sharp (programming language) F# #cite_note-quantFSharp-13 [14] #cite_note-businessAppsFSharp-14 [15] have been used in industrial and commercial applications by a wide variety of organizations. Functional programming is also supported in some /wiki/Domain-specific_programming_language Domain-specific programming language domain-specific programming languages like /wiki/R_(programming_language) R (programming language) R (statistics), #cite_note-useR-15 [16] #cite_note-Chambers-16 [17] /wiki/Mathematica Mathematica Mathematica (symbolic math), #cite_note-Amath-CO-17 [18] /wiki/J_(programming_language) J (programming language) J and /wiki/K_(programming_language) K (programming language) K (financial analysis)[ /wiki/Wikipedia:Citation_needed Wikipedia:Citation needed This claim needs references to reliable sources from August 2009 citation needed] and /wiki/XQuery XQuery XQuery/ /wiki/XSLT XSLT XSLT ( /wiki/XML XML XML). #cite_note-Novatchev-18 [19] #cite_note-Mertz-19 [20] Widespread domain-specific declarative languages like /wiki/SQL SQL SQL and /wiki/Lex_programming_tool Lex programming tool Lex/ /wiki/Yacc Yacc Yacc use some elements of functional programming, especially in eschewing mutable values. #cite_note-Chamberlin_Boyce-20 [21] /wiki/Spreadsheet Spreadsheet Spreadsheets can also be viewed as functional programming languages. #cite_note-excel-21 [22] Programming in a functional style can also be accomplished in languages that aren't specifically designed for functional programming. For example, the imperative /wiki/Perl_(programming_language) Perl (programming language) Perl programming language has been the subject of a book describing how to apply functional programming concepts. #cite_note-22 [23]. C# added constructs in the 3.0 release to facilitate the functional style as well. Contents #History 1 History #Concepts 2 Concepts #First-class_and_higher-order_functions 2.1 First-class and higher-order functions #Pure_functions 2.2 Pure functions #Recursion 2.3 Recursion #Strict_versus_non-strict_evaluation 2.4 Strict versus non-strict evaluation #Type_systems 2.5 Type systems #Functional_programming_in_non-functional_languages 2.6 Functional programming in non-functional languages #Comparison_to_imperative_programming 3 Comparison to imperative programming #Simulating_state 3.1 Simulating state #Efficiency_issues 3.2 Efficiency issues #Coding_styles 3.3 Coding styles #Use_in_industry 4 Use in industry #See_also 5 See also #References 6 References #Further_reading 7 Further reading #External_links 8 External links [ /w/index.php?title=Functional_programming&action=edit&section=1 Edit section: History edit] History /wiki/Lambda_calculus Lambda calculus Lambda calculus provides a theoretical framework for describing functions and their evaluation. Although it is a mathematical abstraction rather than a programming language, it forms the basis of almost all functional programming languages today. An equivalent theoretical formulation, /wiki/Combinatory_logic Combinatory logic combinatory logic, is commonly perceived as more abstract than lambda calculus and preceded it in invention. It is used in some esoteric languages including /wiki/Unlambda Unlambda Unlambda. Combinatory logic and lambda calculus were both originally developed to achieve a clearer approach to the /wiki/Foundations_of_mathematics Foundations of mathematics foundations of mathematics. #cite_note-23 [24] An early functional flavored language was /wiki/Lisp_(programming_language) Lisp (programming language) Lisp, developed by /wiki/John_McCarthy_(computer_scientist) John McCarthy (computer scientist) John McCarthy while at /wiki/Massachusetts_Institute_of_Technology Massachusetts Institute of Technology MIT for the /wiki/IBM_700/7000_series#Scientific_Architecture IBM 700/7000 series IBM 700/7000 series scientific computers in the late 1950s. #cite_note-24 [25] Lisp introduced many features now found in functional languages, though Lisp is technically a multi-paradigm language. /wiki/Scheme_(programming_language) Scheme (programming language) Scheme and /wiki/Dylan_programming_language Dylan programming language Dylan were later attempts to simplify and improve Lisp. /wiki/Information_Processing_Language Information Processing Language Information Processing Language (IPL) is sometimes cited as the first computer-based functional programming language. #cite_note-25 [26] It is an assembly-style language for manipulating lists of symbols. It does have a notion of "generator", which amounts to a function accepting a function as an argument, and, since it is an assembly-level language, code can be used as data, so IPL can be regarded as having higher-order functions. However, it relies heavily on mutating list structure and similar imperative features. /wiki/Kenneth_E._Iverson Kenneth E. Iverson Kenneth E. Iverson developed /wiki/APL_(programming_language) APL (programming language) APL in the early 1960s, described in his 1962 book A Programming Language ( /wiki/Special:BookSources/9780471430148 ISBN 9780471430148). APL was the primary influence on /wiki/John_Backus John Backus John Backus's /wiki/FP_(programming_language) FP (programming language) FP. In the early 1990s, Iverson and /wiki/Roger_Hui Roger Hui Roger Hui created /wiki/J_(programming_language) J (programming language) J. In the mid 1990s, /wiki/Arthur_Whitney_(computer_scientist) Arthur Whitney (computer scientist) Arthur Whitney, who had previously worked with Iverson, created /wiki/K_(programming_language) K (programming language) K, which is used commercially in financial industries along with its descendant /wiki/Q_(programming_language_from_Kx_Systems) Q (programming language from Kx Systems) Q. /wiki/John_Backus John Backus John Backus presented /wiki/FP_(programming_language) FP (programming language) FP in his 1977 /wiki/Turing_Award Turing Award Turing Award lecture "Can Programming Be Liberated From the von Neumann Style? A Functional Style and its Algebra of Programs". #cite_note-26 [27] He defines functional programs as being built up in a hierarchical way by means of "combining forms" that allow an "algebra of programs"; in modern language, this means that functional programs follow the /wiki/Principle_of_compositionality Principle of compositionality principle of compositionality. Backus's paper popularized research into functional programming, though it emphasized /wiki/Function-level_programming Function-level programming function-level programming rather than the lambda-calculus style which has come to be associated with functional programming. In the 1970s, /wiki/ML_(programming_language) ML (programming language) ML was created by /wiki/Robin_Milner Robin Milner Robin Milner at the /wiki/University_of_Edinburgh University of Edinburgh University of Edinburgh, and /wiki/David_Turner_(computer_scientist) David Turner (computer scientist) David Turner developed initially the language /wiki/SASL_(programming_language) SASL (programming language) SASL at the /wiki/University_of_St._Andrews University of St. Andrews University of St. Andrews and later the language /wiki/Miranda_(programming_language) Miranda (programming language) Miranda at the /wiki/University_of_Kent University of Kent University of Kent. ML eventually developed into several dialects, the most common of which are now /wiki/Objective_Caml Objective Caml Objective Caml and /wiki/Standard_ML Standard ML Standard ML. Also in the 1970s, the development of /wiki/Scheme_(programming_language) Scheme (programming language) Scheme (a partly functional dialect of Lisp), as described in the influential /wiki/Lambda_Papers Lambda Papers Lambda Papers and the 1985 textbook /wiki/Structure_and_Interpretation_of_Computer_Programs Structure and Interpretation of Computer Programs Structure and Interpretation of Computer Programs, brought awareness of the power of functional programming to the wider programming-languages community. In the 1980s, /wiki/Per_Martin-L%C3%B6f Per Martin-Löf Per Martin-Löf developed /wiki/Intuitionistic_type_theory Intuitionistic type theory intuitionistic type theory (also called Constructive type theory), which associated functional programs with /wiki/Constructive_proof Constructive proof constructive proofs of arbitrarily complex mathematical propositions expressed as /wiki/Dependent_type Dependent type dependent types. This led to powerful new approaches to /wiki/Interactive_theorem_proving Interactive theorem proving interactive theorem proving and has influenced the development of many subsequent functional programming languages. The /wiki/Haskell_(programming_language) Haskell (programming language) Haskell language began with a consensus in 1987 to form an /wiki/Open_standard Open standard open standard for functional programming research; implementation releases have been ongoing since 1990. [ /w/index.php?title=Functional_programming&action=edit&section=2 Edit section: Concepts edit] Concepts A number of concepts and paradigms are specific to functional programming, and generally foreign to /wiki/Imperative_programming Imperative programming imperative programming (including /wiki/Object-oriented_programming Object-oriented programming object-oriented programming). However, programming languages are often hybrids of several programming paradigms so programmers using "mostly imperative" languages may have utilized some of these concepts. #cite_note-27 [28] [ /w/index.php?title=Functional_programming&action=edit&section=3 Edit section: First-class and higher-order functions edit] First-class and higher-order functions Main articles: /wiki/First-class_function First-class function First-class function and /wiki/Higher-order_function Higher-order function Higher-order function /wiki/Higher-order_function Higher-order function Higher-order functions are functions that can either take other functions as arguments or return them as results (the /wiki/Differential_operator Differential operator differential operator d / dx that produces the /wiki/Derivative Derivative derivative of a function f is an example of this in calculus). Higher-order functions are closely related to /wiki/First-class_function First-class function first-class functions, in that higher-order functions and first-class functions both allow functions as arguments and results of other functions. The distinction between the two is subtle: "higher-order" describes a mathematical concept of functions that operate on other functions, while "first-class" is a computer science term that describes programming language entities that have no restriction on their use (thus first-class functions can appear anywhere in the program that other first-class entities like numbers can, including as arguments to other functions and as their return values). Higher-order functions enable /wiki/Partial_application Partial application partial application or /wiki/Currying Currying currying, a technique in which a function is applied to its arguments one at a time, with each application returning a new function that accepts the next argument. This allows one to succinctly express, for example, the successor function as the addition operator partially applied to the natural number one. [ /w/index.php?title=Functional_programming&action=edit&section=4 Edit section: Pure functions edit] Pure functions /wiki/Purely_functional Purely functional Purely functional functions (or expressions) have no memory or I/O /wiki/Side_effect_(computer_science) Side effect (computer science) side effects. This means that pure functions have several useful properties, many of which can be used to optimize the code: If the result of a pure expression is not used, it can be removed without affecting other expressions. If a pure function is called with parameters that cause no side-effects, the result is constant with respect to that parameter list (sometimes called /wiki/Referential_transparency_(computer_science) Referential transparency (computer science) referential transparency), i.e. if the pure function is again called with the same parameters, the same result will be returned (this can enable caching optimizations such as /wiki/Memoization Memoization memoization). If there is no data dependency between two pure expressions, then their order can be reversed, or they can be performed in /wiki/Parallelization Parallelization parallel and they cannot interfere with one another (in other terms, the evaluation of any pure expression is /wiki/Thread-safe Thread-safe thread-safe). If the entire language does not allow side-effects, then any evaluation strategy can be used; this gives the compiler freedom to reorder or combine the evaluation of expressions in a program (for example, using /wiki/Deforestation_(computer_science) Deforestation (computer science) deforestation). While most compilers for imperative programming languages detect pure functions, and perform common-subexpression elimination for pure function calls, they cannot always do this for pre-compiled libraries, which generally do not expose this information, thus preventing optimizations that involve those external functions. Some compilers, such as /wiki/GNU_Compiler_Collection GNU Compiler Collection gcc, add extra keywords for a programmer to explicitly mark external functions as pure, to enable such optimizations. /wiki/Fortran_95 Fortran 95 Fortran 95 allows functions to be designated "pure". [ /w/index.php?title=Functional_programming&action=edit&section=5 Edit section: Recursion edit] Recursion Main article: /wiki/Recursion_(computer_science) Recursion (computer science) Recursion (computer science) /wiki/Iteration Iteration Iteration (looping) in functional languages is usually accomplished via /wiki/Recursion Recursion recursion. /wiki/Recursion_(computer_science) Recursion (computer science) Recursive functions invoke themselves, allowing an operation to be performed over and over. Recursion may require maintaining a stack, but /wiki/Tail_recursion Tail recursion tail recursion can be recognized and optimized by a compiler into the same code used to implement iteration in imperative languages. The /wiki/Scheme_(programming_language) Scheme (programming language) Scheme language standard requires implementations to recognize and optimize tail recursion. Tail recursion optimization can be implemented by transforming the program into /wiki/Continuation_passing_style Continuation passing style continuation passing style during compiling, among other approaches. Common patterns of recursion can be factored out using higher order functions, with /wiki/Catamorphism Catamorphism catamorphisms and /wiki/Anamorphism Anamorphism anamorphisms (or "folds" and "unfolds") being the most obvious examples. Such higher order functions play a role analogous to built-in control structures such as /wiki/Program_loops Program loops loops in /wiki/Imperative_languages Imperative languages imperative languages. Most general purpose functional programming languages allow unrestricted recursion and are /wiki/Turing_complete Turing complete Turing complete, which makes the /wiki/Halting_problem Halting problem halting problem /wiki/Undecidable_problem Undecidable problem undecidable, can cause unsoundness of /wiki/Equational_reasoning Equational reasoning equational reasoning, and generally requires the introduction of /wiki/Inconsistency Inconsistency inconsistency into the logic expressed by the language's /wiki/Type_system Type system type system. Some special purpose languages such as /wiki/Coq Coq Coq allow only /wiki/Well-founded Well-founded well-founded recursion and are /wiki/Strongly_normalizing Strongly normalizing strongly normalizing (nonterminating computations can be expressed only with infinite streams of values called /wiki/Codata Codata codata). As a consequence, these languages fail to be Turing complete and expressing certain functions in them is impossible, but they can still express a wide class of interesting computations while avoiding the problems introduced by unrestricted recursion. Functional programming limited to well-founded recursion with a few other constraints is called /wiki/Total_functional_programming Total functional programming total functional programming. See Turner 2004 for more discussion. #cite_note-totalfp-28 [29] [ /w/index.php?title=Functional_programming&action=edit&section=6 Edit section: Strict versus non-strict evaluation edit] Strict versus non-strict evaluation Main article: /wiki/Evaluation_strategy Evaluation strategy Evaluation strategy Functional languages can be categorized by whether they use strict (eager) or non-strict (lazy) evaluation, concepts that refer to how function arguments are processed when an expression is being evaluated. The technical difference is in the /wiki/Denotational_semantics Denotational semantics denotational semantics of expressions containing failing or divergent computations. Under strict evaluation, the evaluation of any term containing a failing subterm will itself fail. For example, the expression: print length([2+1, 3*2, 1/0, 5-4]) will fail under strict evaluation because of the division by zero in the third element of the list. Under nonstrict evaluation, the length function will return the value 4, since evaluating it will not attempt to evaluate the terms making up the list. In brief, strict evaluation always fully evaluates function arguments before invoking the function. Non-strict evaluation does not evaluate function arguments unless their values are required to evaluate the function call itself. The usual implementation strategy for non-strict evaluation in functional languages is /wiki/Graph_reduction Graph reduction graph reduction. #cite_note-29 [30] Non-strict evaluation is used by default in several pure functional languages, including /wiki/Miranda_(programming_language) Miranda (programming language) Miranda, /wiki/Clean_(programming_language) Clean (programming language) Clean and /wiki/Haskell_(programming_language) Haskell (programming language) Haskell. Hughes 1984 argues for non-strict evaluation as a mechanism for improving program modularity through /wiki/Separation_of_concerns Separation of concerns separation of concerns, by easing independent implementation of producers and consumers of data streams. #cite_note-30 [31] Launchbury 1993 describes some difficulties that lazy evaluation introduces, particularly in analyzing a program's storage requirements, and proposes an /wiki/Operational_semantics Operational semantics operational semantics to aid in such analysis. #cite_note-launchbury1993-31 [32] Harper 2009 proposes including both strict and nonstrict evaluation in the same language, using the language's type system to distinguish them. #cite_note-32 [33] [ /w/index.php?title=Functional_programming&action=edit&section=7 Edit section: Type systems edit] Type systems Especially since the development of /wiki/Hindley%E2%80%93Milner_type_inference Hindley–Milner type inference Hindley–Milner type inference in the 1970s, functional programming languages have tended to use /wiki/Typed_lambda_calculus Typed lambda calculus typed lambda calculus, as opposed to the /wiki/Untyped_lambda_calculus Untyped lambda calculus untyped lambda calculus used in Lisp and its variants (such as Scheme). The use of /wiki/Algebraic_datatypes Algebraic datatypes algebraic datatypes and /wiki/Pattern_matching Pattern matching pattern matching makes manipulation of complex data structures convenient and expressive; the presence of strong compile-time type checking makes programs more reliable, while /wiki/Type_inference Type inference type inference frees the programmer from the need to manually declare types to the compiler. Some research-oriented functional languages such as /wiki/Coq Coq Coq, /wiki/Agda_(theorem_prover) Agda (theorem prover) Agda, /wiki/Cayenne_(programming_language) Cayenne (programming language) Cayenne, and /wiki/Epigram_(programming_language) Epigram (programming language) Epigram are based on /wiki/Intuitionistic_type_theory Intuitionistic type theory intuitionistic type theory, which allows types to depend on terms. Such types are called /wiki/Dependent_type Dependent type dependent types. These type systems do not have decidable type inference and are difficult to understand and program with[ /wiki/Wikipedia:Citation_needed Wikipedia:Citation needed This claim needs references to reliable sources from December 2011 citation needed]. But dependent types can express arbitrary propositions in /wiki/Predicate_logic Predicate logic predicate logic. Through the /wiki/Curry%E2%80%93Howard_isomorphism Curry–Howard isomorphism Curry–Howard isomorphism, then, well-typed programs in these languages become a means of writing formal /wiki/Mathematical_proof Mathematical proof mathematical proofs from which a compiler can generate /wiki/Formal_verification Formal verification certified code. While these languages are mainly of interest in academic research (including in /w/index.php?title=Formalized_mathematics&action=edit&redlink=1 Formalized mathematics (page does not exist) formalized mathematics), they have begun to be used in engineering as well. /wiki/Compcert Compcert Compcert is a /wiki/Compiler Compiler compiler for a subset of the /wiki/C_(programming_language) C (programming language) C programming language that is written in Coq and formally verified. #cite_note-33 [34] A limited form of dependent types called /wiki/Generalized_algebraic_data_type Generalized algebraic data type generalized algebraic data types (GADT's) can be implemented in a way that provides some of the benefits of dependently-typed programming while avoiding most of its inconvenience. #cite_note-34 [35] GADT's are available in the /wiki/Glasgow_Haskell_Compiler Glasgow Haskell Compiler Glasgow Haskell Compiler and in /wiki/Scala_(programming_language) Scala (programming language) Scala (as "case classes"), and have been proposed as additions to other languages including Java and C#. #cite_note-35 [36] [ /w/index.php?title=Functional_programming&action=edit&section=8 Edit section: Functional programming in non-functional languages edit] Functional programming in non-functional languages It is possible to use a functional style of programming in languages that are not traditionally considered functional languages. #cite_note-36 [37] Among imperative programming languages, the /wiki/D_(programming_language) D (programming language) D programming language's solid support for functional programming stands out.[ /wiki/Wikipedia:Citation_needed Wikipedia:Citation needed This claim needs references to reliable sources from September 2011 citation needed] For example, D has a pure modifier to enforce functional purity. Only /wiki/Fortran_95 Fortran 95 Fortran 95 has something similar. #cite_note-37 [38] First class functions have slowly been added to mainstream languages. For example, in early 1994, support for lambda, filter, map, and reduce was added to /wiki/Python_(programming_language) Python (programming language) Python. Then during the development of Python 3000, /wiki/Guido_van_Rossum Guido van Rossum Guido van Rossum called for the removal of these features. So far, only the reduce function has been removed, #cite_note-38 [39] and it remains accessible via the functools standard library module. #cite_note-39 [40] First class functions were also introduced in /wiki/PHP PHP PHP 5.3, /wiki/Visual_Basic Visual Basic Visual Basic 9, /wiki/C_Sharp_(programming_language) C Sharp (programming language) C# 3.0, and /wiki/C%2B%2B11 C++11 C++11. The /wiki/Language_Integrated_Query Language Integrated Query Language Integrated Query (LINQ) feature, with its many incarnations, is an obvious and powerful use of functional programming in /wiki/.NET_Framework .NET Framework .NET. In /wiki/Java_(programming_language) Java (programming language) Java, /wiki/Anonymous_class Anonymous class anonymous classes can sometimes be used to simulate /wiki/Closure_(computer_science) Closure (computer science) closures;[ /wiki/Wikipedia:Citation_needed Wikipedia:Citation needed This claim needs references to reliable sources from January 2009 citation needed] however, anonymous classes are not always proper replacements to /wiki/Closure_(computer_science) Closure (computer science) closures because they have more limited capabilities. Many /wiki/Object-oriented Object-oriented object-oriented /wiki/Design_pattern_(computer_science) Design pattern (computer science) design patterns are expressible in functional programming terms: for example, the /wiki/Strategy_pattern Strategy pattern strategy pattern simply dictates use of a higher-order function, and the /wiki/Visitor_(design_pattern) Visitor (design pattern) visitor pattern roughly corresponds to a /wiki/Catamorphism Catamorphism catamorphism, or /wiki/Fold_(higher-order_function) Fold (higher-order function) fold. The benefits of immutable data can be seen even in imperative programs, so programmers often strive to make some data immutable even in imperative programs. #cite_note-40 [41] [ /w/index.php?title=Functional_programming&action=edit&section=9 Edit section: Comparison to imperative programming edit] Comparison to imperative programming Functional programming is very different from /wiki/Imperative_programming Imperative programming imperative programming. The most significant differences stem from the fact that functional programming avoids /wiki/Side_effect_(computer_science) Side effect (computer science) side effects, which are used in imperative programming to implement state and I/O. Pure functional programming disallows side effects completely. Disallowing side effects provides for /wiki/Referential_transparency_(computer_science) Referential transparency (computer science) referential transparency, which makes it easier to verify, optimize, and parallelize programs, and easier to write automated tools to perform those tasks. Higher-order functions are rarely used in older imperative programming. Where a traditional imperative program might use a loop to traverse a list, a functional program would use a different technique. It would use a higher-order function that takes as arguments a function and a list. The higher-order function would then apply the given function to each element of the given list and then return a new list with the results. [ /w/index.php?title=Functional_programming&action=edit&section=10 Edit section: Simulating state edit] Simulating state There are tasks (for example, maintaining a bank account balance) that often seem most naturally implemented with state. Pure functional programming performs these tasks, and I/O tasks such as accepting user input and printing to the screen, in a different way. The pure functional programming language /wiki/Haskell_(programming_language) Haskell (programming language) Haskell implements them using /wiki/Monad_(functional_programming) Monad (functional programming) monads, derived from /wiki/Category_theory Category theory category theory. Monads offer a way to abstract certain types of computational patterns, including (but not limited to) modeling of computations with mutable state (and other side effects such as I/O) in an imperative manner without losing purity. While existing monads may be easy to apply in a program, given appropriate templates and examples, many students find them difficult to understand conceptually, e.g., when asked to define new monads (which is sometimes needed for certain types of libraries). #cite_note-41 [42] Impure functional languages usually include a more direct method of managing mutable state. Clojure, for example, uses managed references that can be updated by applying pure functions to the current state. This kind of approach enables mutability while still promoting the use of pure functions as the preferred way to express computations. Alternative methods such as /wiki/Hoare_logic Hoare logic Hoare logic and /wiki/Uniqueness_type Uniqueness type uniqueness have been developed to track side effects in programs. Some modern research languages use /wiki/Effect_system Effect system effect systems to make explicit the presence of side effects. [ /w/index.php?title=Functional_programming&action=edit&section=11 Edit section: Efficiency issues edit] Efficiency issues This section may contain /wiki/Wikipedia:No_original_research Wikipedia:No original research original research. Please //en.wikipedia.org/w/index.php?title=Functional_programming&action=edit improve it by /wiki/Wikipedia:Verifiability Wikipedia:Verifiability verifying the claims made and adding /wiki/Wikipedia:References Wikipedia:References references. Statements consisting only of original research may be removed. More details may be available on the /wiki/Talk:Functional_programming Talk:Functional programming talk page. (May 2009) Functional programming languages are typically less efficient in their use of /wiki/Central_processing_unit Central processing unit CPU and memory than imperative languages such as /wiki/C_programing_language C programing language C and /wiki/Pascal_(programming_language) Pascal (programming language) Pascal. #cite_note-42 [43] For purely functional languages, the worst-case slowdown is logarithmic in the number of memory cells used, because mutable memory can be represented by a purely functional data structure with logarithmic access time (such as a balanced tree).[ /wiki/Wikipedia:Citation_needed Wikipedia:Citation needed This claim needs references to reliable sources from February 2010 citation needed] However, such slowdowns are not universal. For programs that perform intensive numerical computations, functional languages such as /wiki/Objective_Caml Objective Caml Objective Caml and /wiki/Clean_(programming_language) Clean (programming language) Clean are only slightly slower than /wiki/C_(programming_language) C (programming language) C. #cite_note-43 [44] For programs that handle large /wiki/Matrix_(mathematics) Matrix (mathematics) matrices and multidimensional /wiki/Database Database databases, /wiki/Array_programming Array programming array functional languages (such as /wiki/J_(programming_language) J (programming language) J and /wiki/K_(programming_language) K (programming language) K) were designed with speed optimization. Immutability of data can, in many cases, lead to execution efficiency in allowing the compiler to make assumptions that are unsafe in an imperative language, thus increasing opportunities for /wiki/Inline_expansion Inline expansion inline expansion.[ /wiki/Wikipedia:Citation_needed Wikipedia:Citation needed This claim needs references to reliable sources from October 2008 citation needed] /wiki/Lazy_evaluation Lazy evaluation Lazy evaluation may also speed up the program, even asymptotically, whereas it may slow it down at most by a constant factor (however, it may introduce memory leaks when used improperly). Launchbury 1993 #cite_note-launchbury1993-31 [32] discusses theoretical issues related to memory leaks from lazy evaluation, and O'Sullivan et al. 2008 #cite_note-44 [45] give some practical advice for analyzing and fixing them. [ /w/index.php?title=Functional_programming&action=edit&section=12 Edit section: Coding styles edit] Coding styles Imperative programs tend to emphasize the series of steps taken by a program in carrying out an action, while functional programs tend to emphasize the composition and arrangement of functions, often without specifying explicit steps. A simple example illustrates this with two solutions to the same programming goal (calculating /wiki/Fibonacci_number Fibonacci number Fibonacci numbers). The imperative example is in /wiki/C%2B%2B C++ C++. // Fibonacci numbers, imperative style int fibonacci(int iterations) { int first = 0, second = 1; // seed values for (int i = 0; i < iterations; ++i) { int sum = first + second; first = second; second = sum; } return first; } std::cout << fibonacci(10) << "\n"; A functional version (in /wiki/Haskell_(programming_language) Haskell (programming language) Haskell) has a different feel to it: -- Fibonacci numbers, functional style -- describe an infinite list based on the recurrence relation for Fibonacci numbers fibRecurrence first second = first : fibRecurrence second (first + second) -- describe fibonacci list as fibRecurrence with initial values 0 and 1 fibonacci = fibRecurrence 0 1 -- describe action to print the 10th element of the fibonacci list main = print (fibonacci !! 10) The imperative style describes the intermediate steps involved in calculating fibonacci(N), and places those steps inside a /wiki/Program_loops Program loops loop statement. In contrast, the functional implementation shown here states the mathematical /wiki/Recurrence_relation Recurrence relation recurrence relation that defines the entire Fibonacci sequence, then selects an element from the sequence (see also /wiki/Recursion_(computer_science) Recursion (computer science) recursion). This example relies on Haskell's /wiki/Lazy_evaluation Lazy evaluation lazy evaluation to create an "infinite" list of which only as much as needed (the first 10 elements in this case) will actually be computed. That computation happens when the runtime system carries out the action described by "main". [ /w/index.php?title=Functional_programming&action=edit&section=13 Edit section: Use in industry edit] Use in industry Functional programming has long been popular in academia, but with few industrial applications. #cite_note-programmingScala-45 [46]:page 11 However, recently several prominent functional programming languages have been used in commercial or industrial systems. For example, the /wiki/Erlang_(programming_language) Erlang (programming language) Erlang programming language, which was developed by the /wiki/Sweden Sweden Swedish company /wiki/Ericsson Ericsson Ericsson in the late 1980s, was originally used to implement fault-tolerant telecommunications systems. #cite_note-armstrong2007-7 [8] It has since become popular for building a range of applications at companies such as /wiki/T-Mobile T-Mobile T-Mobile, /wiki/Nortel Nortel Nortel, /wiki/Facebook Facebook Facebook and /wiki/EDF EDF EDF. #cite_note-erlang-faq-6 [7] #cite_note-larson2009-8 [9] #cite_note-46 [47] #cite_note-Sim-Diasca-47 [48] The /wiki/Scheme_(programming_language) Scheme (programming language) Scheme dialect of /wiki/Lisp_(programming_language) Lisp (programming language) Lisp was used as the basis for several applications on early /wiki/Apple_Macintosh Apple Macintosh Apple Macintosh computers, #cite_note-clinger1987-1 [2] #cite_note-hartheimer1987-2 [3] and has more recently been applied to problems such as training /w/index.php?title=Software_simulation&action=edit&redlink=1 Software simulation (page does not exist) simulation software #cite_note-kidd2007-3 [4] and /wiki/Telescope Telescope telescope control. #cite_note-cleis2006-4 [5] /wiki/Objective_Caml Objective Caml Objective Caml, which was introduced in the mid 1990s, has seen commercial use in areas such as financial analysis, #cite_note-minksy2008-9 [10] /wiki/Software_driver Software driver driver verification, industrial /wiki/Robot Robot robot programming, and static analysis of /wiki/Embedded_software Embedded software embedded software. #cite_note-leroy2007-10 [11] /wiki/Haskell_(programming_language) Haskell (programming language) Haskell, although initially intended as a research language, #cite_note-hudak2007-12 [13] has also been applied by a range of companies, in areas such as aerospace systems, hardware design, and web programming. #cite_note-haskell-industry-11 [12] #cite_note-hudak2007-12 [13] Other functional programming languages that have seen use in industry include /wiki/Scala_(programming_language) Scala (programming language) Scala, #cite_note-48 [49] /wiki/F_Sharp_(programming_language) F Sharp (programming language) F#, #cite_note-quantFSharp-13 [14] #cite_note-businessAppsFSharp-14 [15] /wiki/Lisp_(programming_language) Lisp (programming language) Lisp, #cite_note-49 [50] Standard ML, #cite_note-50 [51] #cite_note-51 [52] and /wiki/Clojure Clojure Clojure. #cite_note-52 [53] [ /w/index.php?title=Functional_programming&action=edit&section=14 Edit section: See also edit] See also /wiki/Comparison_of_programming_paradigms Comparison of programming paradigms Comparison of programming paradigms /wiki/Eager_evaluation Eager evaluation Eager evaluation /wiki/List_of_functional_programming_topics List of functional programming topics List of functional programming topics /wiki/Nested_function Nested function Nested function [ /w/index.php?title=Functional_programming&action=edit&section=15 Edit section: References edit] References ^ #cite_ref-hudak1989_0-0 a #cite_ref-hudak1989_0-1 b #cite_ref-hudak1989_0-2 c /wiki/Paul_Hudak Paul Hudak Hudak, Paul (September 1989). http://www.cs.berkeley.edu/~jcondit/pl-prelim/hudak89functional.pdf "Conception, evolution, and application of functional programming languages" (PDF). /wiki/Association_for_Computing_Machinery Association for Computing Machinery ACM Computing Surveys 21 (3): 359–411. /wiki/Digital_object_identifier Digital object identifier doi: http://dx.doi.org/10.1145%2F72551.72554 10.1145/72551.72554. http://www.cs.berkeley.edu/~jcondit/pl-prelim/hudak89functional.pdf http://www.cs.berkeley.edu/~jcondit/pl-prelim/hudak89functional.pdf. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&rft.genre=article&rft.atitle=Conception%2C+evolution%2C+and+application+of+functional+programming+languages&rft.jtitle=%5B%5BAssociation+for+Computing+Machinery%7CACM%5D%5D+Computing+Surveys&rft.aulast=Hudak&rft.aufirst=Paul&rft.au=Hudak%2C%26%2332%3BPaul&rft.date=September+1989&rft.volume=21&rft.issue=3&rft.pages=359%E2%80%93411&rft_id=info:doi/10.1145%2F72551.72554&rft_id=http%3A%2F%2Fwww.cs.berkeley.edu%2F%7Ejcondit%2Fpl-prelim%2Fhudak89functional.pdf&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-clinger1987_1-0 a #cite_ref-clinger1987_1-1 b Clinger, Will (1987). http://www.mactech.com/articles/mactech/Vol.03/03.12/Multitasking/index.html "MultiTasking and MacScheme". MacTech 3 (12). http://www.mactech.com/articles/mactech/Vol.03/03.12/Multitasking/index.html http://www.mactech.com/articles/mactech/Vol.03/03.12/Multitasking/index.html. Retrieved 2008-08-28. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&rft.genre=article&rft.atitle=MultiTasking+and+MacScheme&rft.jtitle=MacTech&rft.aulast=Clinger&rft.aufirst=Will&rft.au=Clinger%2C%26%2332%3BWill&rft.date=1987&rft.volume=3&rft.issue=12&rft_id=http%3A%2F%2Fwww.mactech.com%2Farticles%2Fmactech%2FVol.03%2F03.12%2FMultitasking%2Findex.html&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-hartheimer1987_2-0 a #cite_ref-hartheimer1987_2-1 b Hartheimer, Anne (1987). http://www.mactech.com/articles/mactech/Vol.03/03.1/SchemeWindows/index.html "Programming a Text Editor in MacScheme+Toolsmith". MacTech 3 (1). http://www.mactech.com/articles/mactech/Vol.03/03.1/SchemeWindows/index.html http://www.mactech.com/articles/mactech/Vol.03/03.1/SchemeWindows/index.html. Retrieved 2008-08-28. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&rft.genre=article&rft.atitle=Programming+a+Text+Editor+in+MacScheme%2BToolsmith&rft.jtitle=MacTech&rft.aulast=Hartheimer&rft.aufirst=Anne&rft.au=Hartheimer%2C%26%2332%3BAnne&rft.date=1987&rft.volume=3&rft.issue=1&rft_id=http%3A%2F%2Fwww.mactech.com%2Farticles%2Fmactech%2FVol.03%2F03.1%2FSchemeWindows%2Findex.html&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-kidd2007_3-0 a #cite_ref-kidd2007_3-1 b Kidd, Eric. http://cufp.galois.com/2007/abstracts.html#EricKidd "Terrorism Response Training in Scheme". CUFP 2007. http://cufp.galois.com/2007/abstracts.html#EricKidd http://cufp.galois.com/2007/abstracts.html#EricKidd. Retrieved 2009-08-26. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Terrorism+Response+Training+in+Scheme&rft.atitle=&rft.aulast=Kidd&rft.aufirst=Eric&rft.au=Kidd%2C%26%2332%3BEric&rft_id=http%3A%2F%2Fcufp.galois.com%2F2007%2Fabstracts.html%23EricKidd&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-cleis2006_4-0 a #cite_ref-cleis2006_4-1 b Cleis, Richard. http://cufp.galois.com/2006/abstracts.html#RichardCleis "Scheme in Space". CUFP 2006. http://cufp.galois.com/2006/abstracts.html#RichardCleis http://cufp.galois.com/2006/abstracts.html#RichardCleis. Retrieved 2009-08-26. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Scheme+in+Space&rft.atitle=&rft.aulast=Cleis&rft.aufirst=Richard&rft.au=Cleis%2C%26%2332%3BRichard&rft_id=http%3A%2F%2Fcufp.galois.com%2F2006%2Fabstracts.html%23RichardCleis&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-racket-video-games_5-0 ^ http://www.gameenginebook.com/gdc09-statescripting-uncharted2.pdf "State-Based Scripting in Uncharted 2". http://www.gameenginebook.com/gdc09-statescripting-uncharted2.pdf http://www.gameenginebook.com/gdc09-statescripting-uncharted2.pdf. Retrieved 2011-08-08. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=State-Based+Scripting+in+Uncharted+2&rft.atitle=&rft_id=http%3A%2F%2Fwww.gameenginebook.com%2Fgdc09-statescripting-uncharted2.pdf&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-erlang-faq_6-0 a #cite_ref-erlang-faq_6-1 b http://www.erlang.org/faq/faq.html#AEN50 "Who uses Erlang for product development?". Frequently asked questions about Erlang. http://www.erlang.org/faq/faq.html#AEN50 http://www.erlang.org/faq/faq.html#AEN50. Retrieved 2007-08-05. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Who+uses+Erlang+for+product+development%3F&rft.atitle=Frequently+asked+questions+about+Erlang&rft_id=http%3A%2F%2Fwww.erlang.org%2Ffaq%2Ffaq.html%23AEN50&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-armstrong2007_7-0 a #cite_ref-armstrong2007_7-1 b Armstrong, Joe (June 2007). http://doi.acm.org/10.1145/1238844.1238850 "A history of Erlang". Third ACM SIGPLAN Conference on History of Programming Languages. San Diego, California. http://doi.acm.org/10.1145/1238844.1238850 http://doi.acm.org/10.1145/1238844.1238850. Retrieved 2009-08-29. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=A+history+of+Erlang&rft.atitle=&rft.aulast=Armstrong&rft.aufirst=Joe&rft.au=Armstrong%2C%26%2332%3BJoe&rft.date=June+2007&rft.place=San+Diego%2C+California&rft_id=http%3A%2F%2Fdoi.acm.org%2F10.1145%2F1238844.1238850&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-larson2009_8-0 a #cite_ref-larson2009_8-1 b Larson, Jim (March 2009). http://doi.acm.org/10.1145/1467247.1467263 "Erlang for concurrent programming". Communications of the ACM 52 (3): 48. /wiki/Digital_object_identifier Digital object identifier doi: http://dx.doi.org/10.1145%2F1467247.1467263 10.1145/1467247.1467263. http://doi.acm.org/10.1145/1467247.1467263 http://doi.acm.org/10.1145/1467247.1467263. Retrieved 2009-08-29. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&rft.genre=article&rft.atitle=Erlang+for+concurrent+programming&rft.jtitle=Communications+of+the+ACM&rft.aulast=Larson&rft.aufirst=Jim&rft.au=Larson%2C%26%2332%3BJim&rft.date=March+2009&rft.volume=52&rft.issue=3&rft.pages=48&rft_id=info:doi/10.1145%2F1467247.1467263&rft_id=http%3A%2F%2Fdoi.acm.org%2F10.1145%2F1467247.1467263&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-minksy2008_9-0 a #cite_ref-minksy2008_9-1 b Minsky, Yaron; Weeks, Stephen (July 2008). http://journals.cambridge.org/action/displayAbstract?aid=1899164 "Caml Trading — experiences with functional programming on Wall Street". Journal of Functional Programming (Cambridge University Press) 18 (4): 553–564. /wiki/Digital_object_identifier Digital object identifier doi: http://dx.doi.org/10.1017%2FS095679680800676X 10.1017/S095679680800676X. http://journals.cambridge.org/action/displayAbstract?aid=1899164 http://journals.cambridge.org/action/displayAbstract?aid=1899164. Retrieved 2008-08-27. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&rft.genre=article&rft.atitle=Caml+Trading%26nbsp%3B%E2%80%94+experiences+with+functional+programming+on+Wall+Street&rft.jtitle=Journal+of+Functional+Programming&rft.aulast=Minsky&rft.aufirst=Yaron&rft.au=Minsky%2C%26%2332%3BYaron&rft.au=Weeks%2C%26%2332%3BStephen&rft.date=July+2008&rft.volume=18&rft.issue=4&rft.pages=553%E2%80%93564&rft.pub=Cambridge+University+Press&rft_id=info:doi/10.1017%2FS095679680800676X&rft_id=http%3A%2F%2Fjournals.cambridge.org%2Faction%2FdisplayAbstract%3Faid%3D1899164&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-leroy2007_10-0 a #cite_ref-leroy2007_10-1 b Leroy, Xavier. http://cufp.galois.com/2007/slides/XavierLeroy.pdf "Some uses of Caml in Industry". CUFP 2007. http://cufp.galois.com/2007/slides/XavierLeroy.pdf http://cufp.galois.com/2007/slides/XavierLeroy.pdf. Retrieved 2009-08-26. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Some+uses+of+Caml+in+Industry&rft.atitle=&rft.aulast=Leroy&rft.aufirst=Xavier&rft.au=Leroy%2C%26%2332%3BXavier&rft_id=http%3A%2F%2Fcufp.galois.com%2F2007%2Fslides%2FXavierLeroy.pdf&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-haskell-industry_11-0 a #cite_ref-haskell-industry_11-1 b http://www.haskell.org/haskellwiki/Haskell_in_industry "Haskell in industry". Haskell Wiki. http://www.haskell.org/haskellwiki/Haskell_in_industry http://www.haskell.org/haskellwiki/Haskell_in_industry. Retrieved 2009-08-26. "Haskell has a diverse range of use commercially, from aerospace and defense, to finance, to web startups, hardware design firms and lawnmower manufacturers." ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Haskell+in+industry&rft.atitle=Haskell+Wiki&rft_id=http%3A%2F%2Fwww.haskell.org%2Fhaskellwiki%2FHaskell_in_industry&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-hudak2007_12-0 a #cite_ref-hudak2007_12-1 b #cite_ref-hudak2007_12-2 c /wiki/Paul_Hudak Paul Hudak Hudak, Paul; Hughes, J., Jones, S. P., and Wadler, P. (June 2007). http://doi.acm.org/10.1145/1238844.1238856 "A history of Haskell: being lazy with class". Third ACM SIGPLAN Conference on History of Programming Languages. San Diego, California. http://doi.acm.org/10.1145/1238844.1238856 http://doi.acm.org/10.1145/1238844.1238856. Retrieved 2009-08-29. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=A+history+of+Haskell%3A+being+lazy+with+class&rft.atitle=&rft.aulast=Hudak&rft.aufirst=Paul&rft.au=Hudak%2C%26%2332%3BPaul&rft.date=June+2007&rft.place=San+Diego%2C+California&rft_id=http%3A%2F%2Fdoi.acm.org%2F10.1145%2F1238844.1238856&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-quantFSharp_13-0 a #cite_ref-quantFSharp_13-1 b Mansell, Howard (2008). http://cufp.galois.com/2008/abstracts.html#MansellHoward "Quantitative Finance in F#". CUFP 2008. http://cufp.galois.com/2008/abstracts.html#MansellHoward http://cufp.galois.com/2008/abstracts.html#MansellHoward. Retrieved 2009-08-29. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Quantitative+Finance+in+F%23&rft.atitle=&rft.aulast=Mansell&rft.aufirst=Howard&rft.au=Mansell%2C%26%2332%3BHoward&rft.date=2008&rft_id=http%3A%2F%2Fcufp.galois.com%2F2008%2Fabstracts.html%23MansellHoward&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-businessAppsFSharp_14-0 a #cite_ref-businessAppsFSharp_14-1 b Peake, Alex (2009). http://cufp.galois.com/2009/abstracts.html#AlexPeakeAdamGranicz "The First Substantial Line of Business Application in F#". CUFP 2009. http://cufp.galois.com/2009/abstracts.html#AlexPeakeAdamGranicz http://cufp.galois.com/2009/abstracts.html#AlexPeakeAdamGranicz. Retrieved 2009-08-29. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=The+First+Substantial+Line+of+Business+Application+in+F%23&rft.atitle=&rft.aulast=Peake&rft.aufirst=Alex&rft.au=Peake%2C%26%2332%3BAlex&rft.date=2009&rft_id=http%3A%2F%2Fcufp.galois.com%2F2009%2Fabstracts.html%23AlexPeakeAdamGranicz&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-useR_15-0 ^ http://www.r-project.org/useR-2006/program.html "The useR! 2006 conference schedule includes papers on the commercial use of R". R-project.org. 2006-06-08. http://www.r-project.org/useR-2006/program.html http://www.r-project.org/useR-2006/program.html. Retrieved 2011-06-20. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=The+useR%21+2006+conference+schedule+includes+papers+on+the+commercial+use+of+R&rft.atitle=&rft.date=2006-06-08&rft.pub=R-project.org&rft_id=http%3A%2F%2Fwww.r-project.org%2FuseR-2006%2Fprogram.html&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-Chambers_16-0 ^ /wiki/John_Chambers_(programmer) John Chambers (programmer) Chambers, John M. (1998). Programming with Data: A Guide to the S Language. Springer Verlag. pp. 67–70. /wiki/International_Standard_Book_Number International Standard Book Number ISBN  /wiki/Special:BookSources/978-0387985039 Special:BookSources/978-0387985039 978-0387985039. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=book&rft.btitle=Programming+with+Data%3A+A+Guide+to+the+S+Language&rft.aulast=Chambers&rft.aufirst=John+M.&rft.au=Chambers%2C%26%2332%3BJohn+M.&rft.date=1998&rft.pages=pp.%26nbsp%3B67%E2%80%9370&rft.pub=Springer+Verlag&rft.isbn=978-0387985039&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-Amath-CO_17-0 ^ Department of Applied Math, University of Colorado. http://amath.colorado.edu/computing/mmm/funcproc.html "Functional vs. Procedural Programming Language". http://amath.colorado.edu/computing/mmm/funcproc.html http://amath.colorado.edu/computing/mmm/funcproc.html. Retrieved 2006-08-28. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Functional+vs.+Procedural+Programming+Language&rft.atitle=&rft.aulast=Department+of+Applied+Math%2C+University+of+Colorado&rft.au=Department+of+Applied+Math%2C+University+of+Colorado&rft_id=http%3A%2F%2Famath.colorado.edu%2Fcomputing%2Fmmm%2Ffuncproc.html&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-Novatchev_18-0 ^ Dimitre Novatchev. http://www.topxml.com/xsl/articles/fp/ "The Functional Programming Language XSLT — A proof through examples". TopXML. http://www.topxml.com/xsl/articles/fp/ http://www.topxml.com/xsl/articles/fp/. Retrieved May 27, 2006. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=The+Functional+Programming+Language+XSLT%26nbsp%3B%E2%80%94+A+proof+through+examples&rft.atitle=TopXML&rft.aulast=Dimitre+Novatchev&rft.au=Dimitre+Novatchev&rft_id=http%3A%2F%2Fwww.topxml.com%2Fxsl%2Farticles%2Ffp%2F&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-Mertz_19-0 ^ David Mertz. http://gnosis.cx/publish/programming/xml_models_fp.html "XML Programming Paradigms (part four): Functional Programming approached to XML processing". IBM developerWorks. http://gnosis.cx/publish/programming/xml_models_fp.html http://gnosis.cx/publish/programming/xml_models_fp.html. Retrieved May 27, 2006. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=XML+Programming+Paradigms+%28part+four%29%3A+Functional+Programming+approached+to+XML+processing&rft.atitle=IBM+developerWorks&rft.aulast=David+Mertz&rft.au=David+Mertz&rft_id=http%3A%2F%2Fgnosis.cx%2Fpublish%2Fprogramming%2Fxml_models_fp.html&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-Chamberlin_Boyce_20-0 ^ /wiki/Donald_D._Chamberlin Donald D. Chamberlin Donald D. Chamberlin and /wiki/Raymond_F._Boyce Raymond F. Boyce Raymond F. Boyce (1974). "SEQUEL: A structured English query language". Proceedings of the 1974 ACM SIGFIDET: 249–264. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&rft.genre=article&rft.atitle=SEQUEL%3A+A+structured+English+query+language&rft.jtitle=Proceedings+of+the+1974+ACM+SIGFIDET&rft.aulast=%5B%5BDonald+D.+Chamberlin%5D%5D+and+%5B%5BRaymond+F.+Boyce%5D%5D&rft.au=%5B%5BDonald+D.+Chamberlin%5D%5D+and+%5B%5BRaymond+F.+Boyce%5D%5D&rft.date=1974&rft.pages=249%E2%80%93264&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-excel_21-0 ^ /wiki/Simon_Peyton_Jones Simon Peyton Jones Simon Peyton Jones, /w/index.php?title=Margaret_Burnett&action=edit&redlink=1 Margaret Burnett (page does not exist) Margaret Burnett, /w/index.php?title=Alan_Blackwell&action=edit&redlink=1 Alan Blackwell (page does not exist) Alan Blackwell (March 2003). http://research.microsoft.com/~simonpj/papers/excel/index.htm "Improving the world's most popular functional language: user-defined functions in Excel". http://research.microsoft.com/~simonpj/papers/excel/index.htm http://research.microsoft.com/~simonpj/papers/excel/index.htm. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Improving+the+world%27s+most+popular+functional+language%3A+user-defined+functions+in+Excel&rft.atitle=&rft.aulast=%5B%5BSimon+Peyton+Jones%5D%5D%2C+%5B%5BMargaret+Burnett%5D%5D%2C+%5B%5BAlan+Blackwell%5D%5D&rft.au=%5B%5BSimon+Peyton+Jones%5D%5D%2C+%5B%5BMargaret+Burnett%5D%5D%2C+%5B%5BAlan+Blackwell%5D%5D&rft.date=March+2003&rft_id=http%3A%2F%2Fresearch.microsoft.com%2F%7Esimonpj%2Fpapers%2Fexcel%2Findex.htm&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-22 ^ /wiki/Mark_Jason_Dominus Mark Jason Dominus Dominus, Mark J. (2005). /wiki/Higher-Order_Perl Higher-Order Perl Higher-Order Perl. /wiki/Morgan_Kaufmann Morgan Kaufmann Morgan Kaufmann. /wiki/International_Standard_Book_Number International Standard Book Number ISBN  /wiki/Special:BookSources/1558607013 Special:BookSources/1558607013 1558607013. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=book&rft.btitle=%5B%5BHigher-Order+Perl%5D%5D&rft.aulast=Dominus&rft.aufirst=Mark+J.&rft.au=Dominus%2C%26%2332%3BMark+J.&rft.date=2005&rft.pub=%5B%5BMorgan+Kaufmann%5D%5D&rft.isbn=1558607013&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-23 ^ Curry, Haskell Brooks; Robert Feys and Craig, William (1958). Combinatory Logic. Volume I. Amsterdam: North-Holland Publishing Company. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=book&rft.btitle=Combinatory+Logic.+Volume+I&rft.aulast=Curry&rft.aufirst=Haskell+Brooks&rft.au=Curry%2C%26%2332%3BHaskell+Brooks&rft.date=1958&rft.place=Amsterdam&rft.pub=North-Holland+Publishing+Company&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-24 ^ /wiki/John_McCarthy_(computer_scientist) John McCarthy (computer scientist) McCarthy, John (June 1978). http://citeseer.ist.psu.edu/mccarthy78history.html "History of Lisp". In /wiki/Association_for_Computing_Machinery Association for Computing Machinery ACM SIGPLAN History of Programming Languages Conference: 217–223. /wiki/Digital_object_identifier Digital object identifier doi: http://dx.doi.org/10.1145%2F800025.808387 10.1145/800025.808387. http://citeseer.ist.psu.edu/mccarthy78history.html http://citeseer.ist.psu.edu/mccarthy78history.html. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&rft.genre=article&rft.atitle=History+of+Lisp&rft.jtitle=In+%5B%5BAssociation+for+Computing+Machinery%7CACM%5D%5D+SIGPLAN+History+of+Programming+Languages+Conference&rft.aulast=McCarthy&rft.aufirst=John&rft.au=McCarthy%2C%26%2332%3BJohn&rft.date=June+1978&rft.pages=217%E2%80%93223&rft_id=info:doi/10.1145%2F800025.808387&rft_id=http%3A%2F%2Fciteseer.ist.psu.edu%2Fmccarthy78history.html&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-25 ^ The memoir of /wiki/Herbert_Simon Herbert Simon Herbert Simon (1991), Models of My Life pp.189-190 /wiki/Special:BookSources/0465046401 ISBN 0-465-04640-1 claims that he, Al Newell, and Cliff Shaw are "commonly adjudged to be the parents of [the] artificial intelligence [field]", for writing /wiki/Logic_Theorist Logic Theorist Logic Theorist, a program which proved theorems from /wiki/Principia_Mathematica Principia Mathematica Principia Mathematica automatically. In order to accomplish this, they had to invent a language and a paradigm which, which viewed retrospectively, embeds functional programming. #cite_ref-26 ^ http://www.stanford.edu/class/cs242/readings/backus.pdf http://www.stanford.edu/class/cs242/readings/backus.pdf #cite_ref-27 ^ Dick Pountain. http://www.byte.com/art/9408/sec11/art1.htm "Functional Programming Comes of Age". BYTE.com (August 1994). http://www.byte.com/art/9408/sec11/art1.htm http://www.byte.com/art/9408/sec11/art1.htm. Retrieved August 31, 2006. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Functional+Programming+Comes+of+Age&rft.atitle=BYTE.com+%28August+1994%29&rft.aulast=Dick+Pountain&rft.au=Dick+Pountain&rft_id=http%3A%2F%2Fwww.byte.com%2Fart%2F9408%2Fsec11%2Fart1.htm&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-totalfp_28-0 ^ /wiki/David_Turner_(computer_scientist) David Turner (computer scientist) Turner, D.A. (2004-07-28). http://www.jucs.org/jucs_10_7/total_functional_programming "Total Functional Programming". Journal of Universal Computer Science 10 (7): 751–768. /wiki/Digital_object_identifier Digital object identifier doi: http://dx.doi.org/10.3217%2Fjucs-010-07-0751 10.3217/jucs-010-07-0751. http://www.jucs.org/jucs_10_7/total_functional_programming http://www.jucs.org/jucs_10_7/total_functional_programming ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&rft.genre=article&rft.atitle=Total+Functional+Programming&rft.jtitle=Journal+of+Universal+Computer+Science&rft.aulast=Turner&rft.aufirst=D.A.&rft.au=Turner%2C%26%2332%3BD.A.&rft.date=2004-07-28&rft.volume=10&rft.issue=7&rft.pages=751%E2%80%93768&rft_id=info:doi/10.3217%2Fjucs-010-07-0751&rft_id=http%3A%2F%2Fwww.jucs.org%2Fjucs_10_7%2Ftotal_functional_programming&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-29 ^ http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm The Implementation of Functional Programming Languages. Simon Peyton Jones, published by Prentice Hall, 1987 #cite_ref-30 ^ /wiki/John_Hughes_(computer_scientist) John Hughes (computer scientist) John Hughes. http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html "Why Functional Programming Matters". http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Why+Functional+Programming+Matters&rft.atitle=&rft.aulast=John+Hughes&rft.au=John+Hughes&rft_id=http%3A%2F%2Fwww.cse.chalmers.se%2F%7Erjmh%2FPapers%2Fwhyfp.html&rfr_id=info:sid/en.wikipedia.org:Functional_programming   ^ #cite_ref-launchbury1993_31-0 a #cite_ref-launchbury1993_31-1 b John Launchbury (1993). http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2016 "A Natural Semantics for Lazy Evaluation". http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2016 http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2016. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=A+Natural+Semantics+for+Lazy+Evaluation&rft.atitle=&rft.aulast=John+Launchbury&rft.au=John+Launchbury&rft.date=1993&rft_id=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.35.2016&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-32 ^ /wiki/Robert_Harper_(computer_scientist) Robert Harper (computer scientist) Robert W. Harper (2009). http://www.cs.cmu.edu/~rwh/plbook/book.pdf Practical Foundations for Programming Languages. http://www.cs.cmu.edu/~rwh/plbook/book.pdf http://www.cs.cmu.edu/~rwh/plbook/book.pdf. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=book&rft.btitle=Practical+Foundations+for+Programming+Languages&rft.aulast=Robert+W.+Harper&rft.au=Robert+W.+Harper&rft.date=2009&rft_id=http%3A%2F%2Fwww.cs.cmu.edu%2F%7Erwh%2Fplbook%2Fbook.pdf&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-33 ^ http://compcert.inria.fr/doc/index.html "The Compcert verified compiler". http://compcert.inria.fr/doc/index.html http://compcert.inria.fr/doc/index.html. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=The+Compcert+verified+compiler&rft.atitle=&rft_id=http%3A%2F%2Fcompcert.inria.fr%2Fdoc%2Findex.html&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-34 ^ Simon Peyton Jones, Dimitrios Vytiniotis, Stephanie Weirich, and Geoffrey Washburn. http://research.microsoft.com/en-us/um/people/simonpj/papers/gadt/ "Simple unification-based type inference for GADTs". ICFP 2006. pp. 50–61. http://research.microsoft.com/en-us/um/people/simonpj/papers/gadt/ http://research.microsoft.com/en-us/um/people/simonpj/papers/gadt/. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Simple+unification-based+type+inference+for+GADTs&rft.atitle=ICFP+2006&rft.aulast=Simon+Peyton+Jones%2C+Dimitrios+Vytiniotis%2C+Stephanie+Weirich%2C+and+Geoffrey+Washburn&rft.au=Simon+Peyton+Jones%2C+Dimitrios+Vytiniotis%2C+Stephanie+Weirich%2C+and+Geoffrey+Washburn&rft.pages=pp.+50%E2%80%9361&rft_id=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fsimonpj%2Fpapers%2Fgadt%2F&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-35 ^ Andrew Kennedy and Claudio Russo (October 2005). http://research.microsoft.com/~akenn/generics/gadtoop.pdf "Generalized Algebraic Data Types and Object-Oriented Programming". OOPSLA. San Diego, California. http://research.microsoft.com/~akenn/generics/gadtoop.pdf http://research.microsoft.com/~akenn/generics/gadtoop.pdf. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Generalized+Algebraic+Data+Types+and+Object-Oriented+Programming&rft.atitle=OOPSLA&rft.aulast=Andrew+Kennedy+and+Claudio+Russo&rft.au=Andrew+Kennedy+and+Claudio+Russo&rft.date=October+2005&rft.place=San+Diego%2C+California&rft_id=http%3A%2F%2Fresearch.microsoft.com%2F%7Eakenn%2Fgenerics%2Fgadtoop.pdf&rfr_id=info:sid/en.wikipedia.org:Functional_programming   http://lambda-the-ultimate.org/node/1134 source of citation #cite_ref-36 ^ Hartel, Pieter; Henk Muller and Hugh Glaser (March 2004). http://www.ub.utwente.nl/webdocs/ctit/1/00000084.pdf "The Functional C experience" (PDF). The Journal of Functional Programming 14 (2): 129–135. /wiki/Digital_object_identifier Digital object identifier doi: http://dx.doi.org/10.1017%2FS0956796803004817 10.1017/S0956796803004817. http://www.ub.utwente.nl/webdocs/ctit/1/00000084.pdf http://www.ub.utwente.nl/webdocs/ctit/1/00000084.pdf. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&rft.genre=article&rft.atitle=The+Functional+C+experience&rft.jtitle=The+Journal+of+Functional+Programming&rft.aulast=Hartel&rft.aufirst=Pieter&rft.au=Hartel%2C%26%2332%3BPieter&rft.date=March+2004&rft.volume=14&rft.issue=2&rft.pages=129%E2%80%93135&rft_id=info:doi/10.1017%2FS0956796803004817&rft_id=http%3A%2F%2Fwww.ub.utwente.nl%2Fwebdocs%2Fctit%2F1%2F00000084.pdf&rfr_id=info:sid/en.wikipedia.org:Functional_programming  ; David Mertz. http://www-128.ibm.com/developerworks/linux/library/l-prog3.html "Functional programming in Python, Part 3". IBM developerWorks. http://www-128.ibm.com/developerworks/linux/library/l-prog3.html http://www-128.ibm.com/developerworks/linux/library/l-prog3.html. Retrieved 2006-09-17. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Functional+programming+in+Python%2C+Part+3&rft.atitle=IBM+developerWorks&rft.aulast=David+Mertz&rft.au=David+Mertz&rft_id=http%3A%2F%2Fwww-128.ibm.com%2Fdeveloperworks%2Flinux%2Flibrary%2Fl-prog3.html&rfr_id=info:sid/en.wikipedia.org:Functional_programming  ( http://www-128.ibm.com/developerworks/library/l-prog.html Part 1, http://www-128.ibm.com/developerworks/library/l-prog2.html Part 2) #cite_ref-37 ^ http://www.digitalmars.com/d/2.0/function.html#pure-functions "Functions — D Programming Language 2.0". Digital Mars. http://www.digitalmars.com/d/2.0/function.html#pure-functions http://www.digitalmars.com/d/2.0/function.html#pure-functions. Retrieved 2011-06-20. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Functions%26nbsp%3B%E2%80%94+D+Programming+Language+2.0&rft.atitle=&rft.pub=Digital+Mars&rft_id=http%3A%2F%2Fwww.digitalmars.com%2Fd%2F2.0%2Ffunction.html%23pure-functions&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-38 ^ http://www.artima.com/weblogs/viewpost.jsp?thread=98196 "The fate of reduce() in Python 3000". Artima.com. 2005-03-10. http://www.artima.com/weblogs/viewpost.jsp?thread=98196 http://www.artima.com/weblogs/viewpost.jsp?thread=98196. Retrieved 2011-06-20. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=The+fate+of+reduce%28%29+in+Python+3000&rft.atitle=&rft.date=2005-03-10&rft.pub=Artima.com&rft_id=http%3A%2F%2Fwww.artima.com%2Fweblogs%2Fviewpost.jsp%3Fthread%3D98196&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-39 ^ http://docs.python.org/dev/library/functools.html#functools.reduce "functools — Higher order functions and operations on callable objects". Python Software Foundation. 2011-07-31. http://docs.python.org/dev/library/functools.html#functools.reduce http://docs.python.org/dev/library/functools.html#functools.reduce. Retrieved 2011-07-31. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=functools+%E2%80%94+Higher+order+functions+and+operations+on+callable+objects&rft.atitle=&rft.date=2011-07-31&rft.pub=Python+Software+Foundation&rft_id=http%3A%2F%2Fdocs.python.org%2Fdev%2Flibrary%2Ffunctools.html%23functools.reduce&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-40 ^ Bloch, Joshua. Effective Java (Second Edition ed.). pp. Item 15. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=book&rft.btitle=Effective+Java&rft.aulast=Bloch&rft.aufirst=Joshua&rft.au=Bloch%2C%26%2332%3BJoshua&rft.pages=pp.%26nbsp%3BItem+15&rft.edition=Second+Edition&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-41 ^ Newbern, J.. http://monads.haskell.cz/html/index.html/html/ "All About Monads: A comprehensive guide to the theory and practice of monadic programming in Haskell". http://monads.haskell.cz/html/index.html/html/ http://monads.haskell.cz/html/index.html/html/. Retrieved 2008-02-14. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=All+About+Monads%3A+A+comprehensive+guide+to+the+theory+and+practice+of+monadic+programming+in+Haskell&rft.atitle=&rft.aulast=Newbern&rft.aufirst=J.&rft.au=Newbern%2C%26%2332%3BJ.&rft_id=http%3A%2F%2Fmonads.haskell.cz%2Fhtml%2Findex.html%2Fhtml%2F&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-42 ^ /wiki/Lawrence_Paulson Lawrence Paulson Lawrence C. Paulson, ML for the Working Programmer. Cambridge UP, 1996. /wiki/Special:BookSources/052156543X ISBN 052156543X. #cite_ref-43 ^ http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=all&d=data&calc=calculate&gcc=on&clean=on&sbcl=on&ocaml=on&ghc=on&fsharp=on&hipe=on&mzscheme=on "Boxplot Summary | Computer Language Benchmarks Game". Shootout.alioth.debian.org. http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=all&d=data&calc=calculate&gcc=on&clean=on&sbcl=on&ocaml=on&ghc=on&fsharp=on&hipe=on&mzscheme=on http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=all&d=data&calc=calculate&gcc=on&clean=on&sbcl=on&ocaml=on&ghc=on&fsharp=on&hipe=on&mzscheme=on. Retrieved 2011-06-20. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Boxplot+Summary+%26%23124%3B+Computer+Language+Benchmarks+Game&rft.atitle=&rft.pub=Shootout.alioth.debian.org&rft_id=http%3A%2F%2Fshootout.alioth.debian.org%2Fu32%2Fbenchmark.php%3Ftest%3Dall%26lang%3Dall%26d%3Ddata%26calc%3Dcalculate%26gcc%3Don%26clean%3Don%26sbcl%3Don%26ocaml%3Don%26ghc%3Don%26fsharp%3Don%26hipe%3Don%26mzscheme%3Don&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-44 ^ http://book.realworldhaskell.org/read/profiling-and-optimization.html#x_eK1 "Chapter 25. Profiling and optimization". Book.realworldhaskell.org. http://book.realworldhaskell.org/read/profiling-and-optimization.html#x_eK1 http://book.realworldhaskell.org/read/profiling-and-optimization.html#x_eK1. Retrieved 2011-06-20. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Chapter+25.+Profiling+and+optimization&rft.atitle=&rft.pub=Book.realworldhaskell.org&rft_id=http%3A%2F%2Fbook.realworldhaskell.org%2Fread%2Fprofiling-and-optimization.html%23x_eK1&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-programmingScala_45-0 ^ Odersky, Martin; Spoon, Lex; Venners, Bill (December 13, 2010). http://www.artima.com/shop/programming_in_scala_2ed Programming in Scala: A Comprehensive Step-by-step Guide (2nd ed.). /w/index.php?title=Artima_Inc&action=edit&redlink=1 Artima Inc (page does not exist) Artima Inc. pp. 883/852. /wiki/International_Standard_Book_Number International Standard Book Number ISBN  /wiki/Special:BookSources/9780981531649 Special:BookSources/9780981531649 9780981531649. http://www.artima.com/shop/programming_in_scala_2ed http://www.artima.com/shop/programming_in_scala_2ed. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=book&rft.btitle=Programming+in+Scala%3A+A+Comprehensive+Step-by-step+Guide&rft.aulast=Odersky&rft.aufirst=Martin&rft.au=Odersky%2C%26%2332%3BMartin&rft.au=Spoon%2C%26%2332%3BLex&rft.au=Venners%2C%26%2332%3BBill&rft.date=December+13%2C+2010&rft.pages=pp.%26nbsp%3B883%2F852&rft.edition=2nd&rft.pub=%5B%5BArtima+Inc%5D%5D&rft.isbn=9780981531649&rft_id=http%3A%2F%2Fwww.artima.com%2Fshop%2Fprogramming_in_scala_2ed&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-46 ^ Piro, Christopher (2009). http://cufp.galois.com/2009/abstracts.html#ChristopherPiroEugeneLetuchy "Functional Programming at Facebook". CUFP 2009. http://cufp.galois.com/2009/abstracts.html#ChristopherPiroEugeneLetuchy http://cufp.galois.com/2009/abstracts.html#ChristopherPiroEugeneLetuchy. Retrieved 2009-08-29. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Functional+Programming+at+Facebook&rft.atitle=&rft.aulast=Piro&rft.aufirst=Christopher&rft.au=Piro%2C%26%2332%3BChristopher&rft.date=2009&rft_id=http%3A%2F%2Fcufp.galois.com%2F2009%2Fabstracts.html%23ChristopherPiroEugeneLetuchy&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-Sim-Diasca_47-0 ^ http://research.edf.com/research-and-the-scientific-community/software/sim-diasca-80704.html "Sim-Diasca: a large-scale discrete event concurrent simulation engine in Erlang". November 2011. http://research.edf.com/research-and-the-scientific-community/software/sim-diasca-80704.html http://research.edf.com/research-and-the-scientific-community/software/sim-diasca-80704.html. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Sim-Diasca%3A+a+large-scale+discrete+event+concurrent+simulation+engine+in+Erlang&rft.atitle=&rft.date=November+2011&rft_id=http%3A%2F%2Fresearch.edf.com%2Fresearch-and-the-scientific-community%2Fsoftware%2Fsim-diasca-80704.html&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-48 ^ Momtahan, Lee (2009). http://cufp.galois.com/2009/abstracts.html#LeeMomtahan "Scala at EDF Trading: Implementing a Domain-Specific Language for Derivative Pricing with Scala". CUFP 2009. http://cufp.galois.com/2009/abstracts.html#LeeMomtahan http://cufp.galois.com/2009/abstracts.html#LeeMomtahan. Retrieved 2009-08-29. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Scala+at+EDF+Trading%3A+Implementing+a+Domain-Specific+Language+for+Derivative+Pricing+with+Scala&rft.atitle=&rft.aulast=Momtahan&rft.aufirst=Lee&rft.au=Momtahan%2C%26%2332%3BLee&rft.date=2009&rft_id=http%3A%2F%2Fcufp.galois.com%2F2009%2Fabstracts.html%23LeeMomtahan&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-49 ^ Graham, Paul (2003). http://www.paulgraham.com/avg.html "Beating the Averages". http://www.paulgraham.com/avg.html http://www.paulgraham.com/avg.html. Retrieved 2009-08-29. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Beating+the+Averages&rft.atitle=&rft.aulast=Graham&rft.aufirst=Paul&rft.au=Graham%2C%26%2332%3BPaul&rft.date=2003&rft_id=http%3A%2F%2Fwww.paulgraham.com%2Favg.html&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-50 ^ Sims, Steve (2006). http://cufp.galois.com/2006/slides/SteveSims.pdf "Building a Startup with Standard ML". CUFP 2006. http://cufp.galois.com/2006/slides/SteveSims.pdf http://cufp.galois.com/2006/slides/SteveSims.pdf. Retrieved 2009-08-29. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Building+a+Startup+with+Standard+ML&rft.atitle=&rft.aulast=Sims&rft.aufirst=Steve&rft.au=Sims%2C%26%2332%3BSteve&rft.date=2006&rft_id=http%3A%2F%2Fcufp.galois.com%2F2006%2Fslides%2FSteveSims.pdf&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-51 ^ Laurikari, Ville (2007). http://cufp.galois.com/2007/abstracts.html#VilleLaurikari "Functional Programming in Communications Security.". CUFP 2007. http://cufp.galois.com/2007/abstracts.html#VilleLaurikari http://cufp.galois.com/2007/abstracts.html#VilleLaurikari. Retrieved 2009-08-29. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Functional+Programming+in+Communications+Security.&rft.atitle=&rft.aulast=Laurikari&rft.aufirst=Ville&rft.au=Laurikari%2C%26%2332%3BVille&rft.date=2007&rft_id=http%3A%2F%2Fcufp.galois.com%2F2007%2Fabstracts.html%23VilleLaurikari&rfr_id=info:sid/en.wikipedia.org:Functional_programming   #cite_ref-52 ^ Lorimer, R. J.. http://www.infoq.com/news/2009/01/clojure_production "Live Production Clojure Application Announced". http://www.infoq.com/news/2009/01/clojure_production http://www.infoq.com/news/2009/01/clojure_production. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=bookitem&rft.btitle=Live+Production+Clojure+Application+Announced&rft.atitle=&rft.aulast=Lorimer&rft.aufirst=R.+J.&rft.au=Lorimer%2C%26%2332%3BR.+J.&rft_id=http%3A%2F%2Fwww.infoq.com%2Fnews%2F2009%2F01%2Fclojure_production&rfr_id=info:sid/en.wikipedia.org:Functional_programming   [ /w/index.php?title=Functional_programming&action=edit&section=16 Edit section: Further reading edit] Further reading /wiki/Hal_Abelson Hal Abelson Abelson, Hal; /wiki/Gerald_Jay_Sussman Gerald Jay Sussman Sussman, Gerald Jay (1985). http://mitpress.mit.edu/sicp/ /wiki/Structure_and_Interpretation_of_Computer_Programs Structure and Interpretation of Computer Programs Structure and Interpretation of Computer Programs. MIT Press. http://mitpress.mit.edu/sicp/ http://mitpress.mit.edu/sicp/. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=book&rft.btitle=%5B%5BStructure+and+Interpretation+of+Computer+Programs%5D%5D&rft.aulast=Abelson&rft.aufirst=Hal&rft.au=Abelson%2C%26%2332%3BHal&rft.au=Sussman%2C%26%2332%3BGerald+Jay&rft.date=1985&rft.pub=MIT+Press&rft_id=http%3A%2F%2Fmitpress.mit.edu%2Fsicp%2F&rfr_id=info:sid/en.wikipedia.org:Functional_programming   Cousineau, Guy and Michel Mauny. The Functional Approach to Programming. Cambridge, UK: /wiki/Cambridge_University_Press Cambridge University Press Cambridge University Press, 1998. Curry, Haskell Brooks and Feys, Robert and Craig, William. Combinatory Logic. Volume I. North-Holland Publishing Company, Amsterdam, 1958. /wiki/Haskell_Curry Haskell Curry Curry, Haskell B.; /wiki/J._Roger_Hindley J. Roger Hindley Hindley, J. Roger; /w/index.php?title=Jonathan_P._Seldin&action=edit&redlink=1 Jonathan P. Seldin (page does not exist) Seldin, Jonathan P. (1972). Combinatory Logic. Vol. II. Amsterdam: North Holland. /wiki/International_Standard_Book_Number International Standard Book Number ISBN  /wiki/Special:BookSources/0-7204-2208-6 Special:BookSources/0-7204-2208-6 0-7204-2208-6. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=book&rft.btitle=Combinatory+Logic&rft.aulast=Curry&rft.aufirst=Haskell+B.&rft.au=Curry%2C%26%2332%3BHaskell+B.&rft.au=Hindley%2C%26%2332%3BJ.+Roger&rft.au=Seldin%2C%26%2332%3BJonathan+P.&rft.date=1972&rft.volume=Vol.+II&rft.place=Amsterdam&rft.pub=North+Holland&rft.isbn=0-7204-2208-6&rfr_id=info:sid/en.wikipedia.org:Functional_programming   /wiki/Mark_Jason_Dominus Mark Jason Dominus Dominus, Mark Jason. /wiki/Higher-Order_Perl Higher-Order Perl Higher-Order Perl. /wiki/Morgan_Kaufmann Morgan Kaufmann Morgan Kaufmann. 2005. Felleisen, Matthias; Findler, Robert; Flatt, Matthew; Krishnamurthi, Shriram (2001). http://www.htdp.org /wiki/How_to_Design_Programs How to Design Programs How to Design Programs. MIT Press. http://www.htdp.org http://www.htdp.org. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=book&rft.btitle=%5B%5BHow+to+Design+Programs%5D%5D&rft.aulast=Felleisen&rft.aufirst=Matthias&rft.au=Felleisen%2C%26%2332%3BMatthias&rft.au=Findler%2C%26%2332%3BRobert&rft.au=Flatt%2C%26%2332%3BMatthew&rft.au=Krishnamurthi%2C%26%2332%3BShriram&rft.date=2001&rft.pub=MIT+Press&rft_id=http%3A%2F%2Fwww.htdp.org&rfr_id=info:sid/en.wikipedia.org:Functional_programming   Graham, Paul. ANSI Common LISP. Englewood Cliffs, New Jersey: /wiki/Prentice_Hall Prentice Hall Prentice Hall, 1996. MacLennan, Bruce J. Functional Programming: Practice and Theory. Addison-Wesley, 1990. O'Sullivan, Brian; Stewart, Don; Goerzen, John (2008). http://book.realworldhaskell.org/read/ Real World Haskell. O'Reilly. http://book.realworldhaskell.org/read/ http://book.realworldhaskell.org/read/. ctx_ver=Z39.88-2004&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&rft.genre=book&rft.btitle=Real+World+Haskell&rft.aulast=O%27Sullivan&rft.aufirst=Brian&rft.au=O%27Sullivan%2C%26%2332%3BBrian&rft.au=Stewart%2C%26%2332%3BDon&rft.au=Goerzen%2C%26%2332%3BJohn&rft.date=2008&rft.pub=O%27Reilly&rft_id=http%3A%2F%2Fbook.realworldhaskell.org%2Fread%2F&rfr_id=info:sid/en.wikipedia.org:Functional_programming   Pratt, Terrence, W. and Marvin V. Zelkowitz. Programming Languages: Design and Implementation. 3rd ed. Englewood Cliffs, New Jersey: /wiki/Prentice_Hall Prentice Hall Prentice Hall, 1996. Salus, Peter H. Functional and Logic Programming Languages. Vol. 4 of Handbook of Programming Languages. Indianapolis, Indiana: /w/index.php?title=Macmillan_Technical_Publishing&action=edit&redlink=1 Macmillan Technical Publishing (page does not exist) Macmillan Technical Publishing, 1998. Thompson, Simon. Haskell: The Craft of Functional Programming. Harlow, England: /w/index.php?title=Addison-Wesley_Longman_Limited&action=edit&redlink=1 Addison-Wesley Longman Limited (page does not exist) Addison-Wesley Longman Limited, 1996. [ /w/index.php?title=Functional_programming&action=edit&section=17 Edit section: External links edit] External links Listen to this article ( /wiki/File:En-Functional_programming.ogg File:En-Functional programming.ogg info/dl) Play sound Play sound This audio file was created from a revision of the "Functional programming" article dated 2011-08-25, and does not reflect subsequent edits to the article. ( /wiki/Wikipedia:Media_help Wikipedia:Media help Audio help) /wiki/Wikipedia:Spoken_articles Wikipedia:Spoken articles More spoken articles /wiki/File:En-Functional_programming.ogg File:En-Functional programming.ogg Sound-icon.svg http://www.defmacro.or
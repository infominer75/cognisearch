Procedural programming - Wikipedia, the free encyclopedia MediaWiki 1.18wmf1 Edit this page /w/index.php?title=Procedural_programming&action=edit Edit this page /w/index.php?title=Procedural_programming&action=edit //en.wikipedia.org/apple-touch-icon.png /favicon.ico /w/opensearch_desc.php Wikipedia (en) //en.wikipedia.org/w/api.php?action=rsd //creativecommons.org/licenses/by-sa/3.0/ Wikipedia Atom feed /w/index.php?title=Special:RecentChanges&feed=atom //bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&lang=en&modules=ext.wikihiero%7Cmediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&only=styles&skin=vector&* //bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&lang=en&modules=site&only=styles&skin=vector&* Procedural programming From Wikipedia, the free encyclopedia Jump to: #mw-head navigation, #p-search search This article is about the computer programming paradigm. For the method of algorithmic content creation, see /wiki/Procedural_generation Procedural generation Procedural generation. This article needs additional /wiki/Wikipedia:Citing_sources#Inline_citations Wikipedia:Citing sources citations for /wiki/Wikipedia:Verifiability Wikipedia:Verifiability verification. Please help //en.wikipedia.org/w/index.php?title=Procedural_programming&action=edit improve this article by adding citations to /wiki/Wikipedia:Identifying_reliable_sources Wikipedia:Identifying reliable sources reliable sources. Unsourced material may be /wiki/Template:Citation_needed Template:Citation needed challenged and /wiki/Wikipedia:Verifiability#Burden_of_evidence Wikipedia:Verifiability removed. (April 2008) /wiki/Programming_paradigm Programming paradigm Programming paradigms /wiki/Agent-oriented_programming Agent-oriented programming Agent-oriented /wiki/Automata-based_programming Automata-based programming Automata-based /wiki/Component-based_software_engineering Component-based software engineering Component-based /wiki/Flow-based_programming Flow-based programming Flow-based /wiki/Pipeline_programming Pipeline programming Pipelined /wiki/Concatenative_programming_language Concatenative programming language Concatenative /wiki/Concurrent_computing Concurrent computing Concurrent computing /wiki/Relativistic_programming Relativistic programming Relativistic programming /wiki/Data-driven_programming Data-driven programming Data-driven /wiki/Declarative_programming Declarative programming Declarative (contrast: /wiki/Imperative_programming Imperative programming Imperative) /wiki/Constraint_programming Constraint programming Constraint /wiki/Dataflow_programming Dataflow programming Dataflow Cell-oriented ( /wiki/Spreadsheet Spreadsheet spreadsheets) /wiki/Reactive_programming Reactive programming Reactive /wiki/Logic_programming Logic programming Logic /wiki/Abductive_logic_programming Abductive logic programming Abductive logic /wiki/Answer_set_programming Answer set programming Answer set /wiki/Constraint_logic_programming Constraint logic programming Constraint logic /wiki/Functional_logic_programming Functional logic programming Functional logic /wiki/Inductive_logic_programming Inductive logic programming Inductive logic /wiki/Event-driven_programming Event-driven programming Event-driven /wiki/Service-oriented_architecture Service-oriented architecture Service-oriented /wiki/Time-driven_programming Time-driven programming Time-driven /wiki/Expression-oriented_programming_language Expression-oriented programming language Expression-oriented /wiki/Feature_Oriented_Programming Feature Oriented Programming Feature-oriented /wiki/Function-level_programming Function-level programming Function-level (contrast: /wiki/Value-level_programming Value-level programming Value-level) /wiki/Functional_programming Functional programming Functional /wiki/Generic_programming Generic programming Generic /wiki/Imperative_programming Imperative programming Imperative (contrast: /wiki/Declarative_programming Declarative programming Declarative) Procedural /wiki/Language-oriented_programming Language-oriented programming Language-oriented /wiki/Service-oriented_modeling#Discipline-specific_modeling Service-oriented modeling Discipline-specific /wiki/Domain-specific_language Domain-specific language Domain-specific /wiki/Grammar-oriented_programming Grammar-oriented programming Grammar-oriented /wiki/Dialecting Dialecting Dialecting /wiki/Intentional_programming Intentional programming Intentional /wiki/Metaprogramming Metaprogramming Metaprogramming /wiki/Automatic_programming Automatic programming Automatic /wiki/Reflection_(computer_programming) Reflection (computer programming) Reflective /wiki/Attribute-oriented_programming Attribute-oriented programming Attribute-oriented /wiki/Template_metaprogramming Template metaprogramming Template /wiki/Policy-based_design Policy-based design Policy-based /wiki/Non-structured_programming Non-structured programming Non-structured (contrast: /wiki/Structured_programming Structured programming Structured) /wiki/Array_programming Array programming Array /wiki/Nondeterministic_programming Nondeterministic programming Nondeterministic /wiki/Parallel_computing Parallel computing Parallel computing /wiki/Process-oriented_programming Process-oriented programming Process-oriented /wiki/Programming_in_the_large_and_programming_in_the_small Programming in the large and programming in the small Programming in the large / small /wiki/Semantic-oriented_programming Semantic-oriented programming Semantic /wiki/Structured_programming Structured programming Structured (contrast: /wiki/Non-structured_programming Non-structured programming Non-structured) /wiki/Modular_programming Modular programming Modular (contrast: Monolithic) /wiki/Object-oriented_programming Object-oriented programming Object-oriented By /wiki/Separation_of_concerns Separation of concerns separation of concerns: /wiki/Aspect-oriented_programming Aspect-oriented programming Aspect-oriented /wiki/Role-oriented_programming Role-oriented programming Role-oriented /wiki/Subject-oriented_programming Subject-oriented programming Subject-oriented /wiki/Class-based_programming Class-based programming Class-based /wiki/Prototype-based_programming Prototype-based programming Prototype-based /wiki/Recursion_(computer_science) Recursion (computer science) Recursive /wiki/Value-level_programming Value-level programming Value-level (contrast: /wiki/Function-level_programming Function-level programming Function-level) /wiki/Template:Programming_paradigms Template:Programming paradigms View this template v /wiki/Template_talk:Programming_paradigms Template talk:Programming paradigms Discuss this template d //en.wikipedia.org/w/index.php?title=Template:Programming_paradigms&action=edit Edit this template e Procedural programming can sometimes be used as a synonym for /wiki/Imperative_programming Imperative programming imperative programming (specifying the steps the program must take to reach the desired state), but can also refer (as in this article) to a /wiki/Programming_paradigm Programming paradigm programming paradigm, derived from /wiki/Structured_programming Structured programming structured programming, based upon the concept of the procedure call. Procedures, also known as routines, /wiki/Subroutine Subroutine subroutines, methods, or functions (not to be confused with mathematical functions, but similar to those used in /wiki/Functional_programming Functional programming functional programming), simply contain a series of computational steps to be carried out. Any given procedure might be called at any point during a program's execution, including by other procedures or itself. #cite_note-0 [1] Contents #Procedures_and_modularity 1 Procedures and modularity #Comparison_with_imperative_programming 2 Comparison with imperative programming #Comparison_with_object-oriented_programming 3 Comparison with object-oriented programming #Comparison_with_functional_programming 4 Comparison with functional programming #Comparison_with_logic_programming 5 Comparison with logic programming #See_also 6 See also #References 7 References #External_links 8 External links [ /w/index.php?title=Procedural_programming&action=edit&section=1 Edit section: Procedures and modularity edit] Procedures and modularity Main article: /wiki/Modular_programming Modular programming Modular programming /wiki/Modularity_(programming) Modularity (programming) Modularity is generally desirable, especially in large, complicated programs. Inputs are usually specified syntactically in the form of arguments and the outputs delivered as return values. /wiki/Scoping Scoping Scoping is another technique that helps keep procedures strongly modular. It prevents the procedure from accessing the variables of other procedures (and vice-versa), including previous instances of itself, without explicit authorization. Less modular procedures, often used in small or quickly written programs, tend to interact with a large number of /wiki/Variable_(programming) Variable (programming) variables in the execution /wiki/System_platform System platform environment, which other procedures might also modify. Because of the ability to specify a simple interface, to be self-contained, and to be reused, procedures are a convenient vehicle for making pieces of code written by different people or different groups, including through /wiki/Code_library Code library programming libraries. [ /w/index.php?title=Procedural_programming&action=edit&section=2 Edit section: Comparison with imperative programming edit] Comparison with imperative programming Procedural programming languages are also /wiki/Imperative_programming Imperative programming imperative languages, because they make explicit references to the state of the execution environment. This could be anything from variables (which may correspond to /wiki/Processor_register Processor register processor registers) to something like the position of the "turtle" in the /wiki/Logo_programming_language Logo programming language Logo programming language. [ /w/index.php?title=Procedural_programming&action=edit&section=3 Edit section: Comparison with object-oriented programming edit] Comparison with object-oriented programming The focus of procedural programming is to break down a programming task into a collection of /wiki/Variable_(programming) Variable (programming) variables, /wiki/Data_structure Data structure data structures, and /wiki/Subroutine Subroutine subroutines, whereas in /wiki/Object-oriented_programming Object-oriented programming object-oriented programming it is to break down a programming task into data types ( /wiki/Class_(computer_science) Class (computer science) classes) that associate behavior (methods) with data (members or attributes). The most important distinction is whereas procedural programming uses procedures to operate on data structures, object-oriented programming bundles the two together so an "object", which is an instance of a class, operates on its "own" data structure. Nomenclature varies between the two, although they have similar semantics: Procedural Object-oriented procedure method /wiki/Record_(computer_science) Record (computer science) record object module class procedure call message See /wiki/Algorithms_%2B_Data_Structures_%3D_Programs Algorithms + Data Structures = Programs Algorithms + Data Structures = Programs. [ /w/index.php?title=Procedural_programming&action=edit&section=4 Edit section: Comparison with functional programming edit] Comparison with functional programming The principles of modularity and code reuse in practical /wiki/Functional_programming Functional programming functional languages are fundamentally the same as in procedural languages, since they both stem from /wiki/Structured_programming Structured programming structured programming. So for example: Procedures correspond to functions. Both allow the reuse of the same code in various parts of the programs, and at various points of its execution. By the same token, procedure calls correspond to function application. Functions and their invocations are modularly separated from each other in the same manner, by the use of function arguments, return values and variable scopes. The main difference between the styles is that functional programming languages remove or at least deemphasize the imperative elements of procedural programming. The feature set of functional languages is therefore designed to support writing programs as much as possible in terms of pure functions: Whereas procedural languages model execution of the program as a sequence of imperative commands that may implicitly alter shared state, functional programming languages model execution as the evaluation of complex expressions that only depend on each other in terms of arguments and return values. For this reason, functional programs can have a freer order of code execution, and the languages may offer little control over the order in which various parts of the program are executed. (For example, the arguments to a procedure invocation in /wiki/Scheme_(programming_language) Scheme (programming language) Scheme are executed in an arbitrary order.) Functional programming languages support (and heavily use) /wiki/First-class_functions First-class functions first-class functions, /wiki/Anonymous_functions Anonymous functions anonymous functions and /wiki/Closure_(computer_science) Closure (computer science) closures. Functional programming languages tend to rely on /wiki/Tail_call_optimization Tail call optimization tail call optimization and /wiki/Higher-order_functions Higher-order functions higher-order functions instead of imperative looping constructs. Many functional languages, however, are in fact impurely functional and offer imperative/procedural constructs that allow the programmer to write programs in procedural style, or in a combination of both styles. It is common for /wiki/Input/output Input/output input/output code in functional languages to be written in a procedural style. There do exist a few /wiki/Esoteric_programming_language Esoteric programming language esoteric functional languages (like /wiki/Unlambda Unlambda Unlambda) that eschew /wiki/Structured_programming Structured programming structured programming precepts for the sake of being difficult to program in (and therefore challenging). These languages are the exception to the common ground between procedural and functional languages. [ /w/index.php?title=Procedural_programming&action=edit&section=5 Edit section: Comparison with logic programming edit] Comparison with logic programming In /wiki/Logic_programming Logic programming logic programming, a program is a set of premises, and computation is performed by attempting to prove candidate theorems. From this point of view, logic programs are /wiki/Declarative_programming Declarative programming declarative, focusing on what the problem is, rather than on how to solve it. However, the /wiki/Backward_reasoning Backward reasoning backward reasoning technique, implemented by /wiki/SLD_resolution SLD resolution SLD resolution, used to solve problems in logic programming languages such as /wiki/Prolog Prolog Prolog, treats programs as goal-reduction procedures. Thus clauses of the form: H :- B1, É, Bn. have a dual interpretation, both as procedures to show/solve H, show/solve B1 and É and Bn and as logical implications: B1 and É and Bn implies H. Experienced logic programmers use the procedural interpretation to write programs that are effective and efficient, and they use the declarative interpretation to help ensure that programs are correct. [ /w/index.php?title=Procedural_programming&action=edit&section=6 Edit section: See also edit] See also /wiki/Comparison_of_programming_paradigms Comparison of programming paradigms Comparison of programming paradigms /wiki/Declarative_programming Declarative programming Declarative programming /wiki/Functional_programming Functional programming Functional programming (contrast) /wiki/Imperative_programming Imperative programming Imperative programming /wiki/Logic_programming Logic programming Logic programming /wiki/Object-oriented_programming Object-oriented programming Object-oriented programming /wiki/Programming_paradigm Programming paradigm Programming paradigms /wiki/Program